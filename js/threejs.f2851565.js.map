{"version":3,"sources":["webpack:///./src/modules/threejs/threejs3.vue","webpack:///src/modules/threejs/threejs3.vue","webpack:///./src/modules/threejs/threejs3.vue?a7f3","webpack:///./src/modules/threejs/threejs3.vue?edee","webpack:///./src/modules/threejs/threejs2.vue?0486","webpack:///./src/modules/threejs/threejs2.vue","webpack:///src/modules/threejs/threejs2.vue","webpack:///./src/modules/threejs/threejs2.vue?c8df","webpack:///./src/modules/threejs/threejs2.vue?0e90","webpack:///./src/modules/threejs/threejs4.vue","webpack:///src/modules/threejs/threejs4.vue","webpack:///./src/modules/threejs/threejs4.vue?572c","webpack:///./src/modules/threejs/threejs4.vue?d19b","webpack:////Users/weimo/mine/code/demo-code/node_modules/core-js/modules/web.url-search-params.size.js","webpack:///./src/modules/threejs/threejs5.vue?5cac","webpack:///./src/modules/threejs/threejs6.vue?96ee","webpack:////Users/weimo/mine/code/demo-code/node_modules/core-js/modules/web.url-search-params.delete.js","webpack:///./src/modules/threejs/threejs3.vue?ad76","webpack:///./src/modules/threejs/threejs5.vue","webpack:///src/modules/threejs/threejs5.vue","webpack:///./src/modules/threejs/threejs5.vue?1415","webpack:///./src/modules/threejs/threejs5.vue?13c7","webpack:///./src/modules/threejs/threejs6.vue","webpack:////Users/weimo/mine/code/demo-code/node_modules/three/examples/jsm/utils/BufferGeometryUtils.js","webpack:////Users/weimo/mine/code/demo-code/node_modules/three/examples/jsm/loaders/GLTFLoader.js","webpack:///src/modules/threejs/threejs6.vue","webpack:///./src/modules/threejs/threejs6.vue?7737","webpack:///./src/modules/threejs/threejs6.vue?1f2b","webpack:////Users/weimo/mine/code/demo-code/node_modules/core-js/internals/validate-arguments-length.js","webpack:////Users/weimo/mine/code/demo-code/node_modules/core-js/modules/web.url-search-params.has.js","webpack:///./src/modules/threejs/threejs4.vue?e3fb"],"names":["render","_vm","this","_c","_self","staticClass","_v","_m","attrs","staticRenderFns","data","fov","aspect","near","far","boxWidth","boxHeight","boxDepth","mounted","main","methods","canvas","document","querySelector","renderer","THREE","antialias","camera","console","log","position","x","z","y","scene","geometry","material","color","cube","time","rotation","cubes","forEach","ndx","speed","rot","requestAnimationFrame","add","intensity","light","makeInstance","set","component","resizeRendererToDisplaySize","domElement","width","clientWidth","height","clientHeight","needResize","setSize","updateProjectionMatrix","staticStyle","on","state3","renderer3","main2","init3","animate3","render3","screenShotDownload","saveBlob","a","createElement","body","appendChild","style","display","blob","fileName","url","window","URL","createObjectURL","href","download","click","getElementById","toBlob","screenShot","img","toDataURL","src","DESCRIPTORS","uncurryThis","defineBuiltInAccessor","URLSearchParamsPrototype","URLSearchParams","prototype","get","count","configurable","enumerable","defineBuiltIn","toString","validateArgumentsLength","$URLSearchParams","append","$delete","push","params","undefined","name","length","arguments","$value","entries","v","k","key","value","entry","index","dindex","found","entriesLength","unsafe","innerWidth","innerHeight","lookAt","material1","points","geometry1","setFromPoints","line","code","toTrianglesDrawMode","drawMode","warn","getIndex","indices","getAttribute","error","i","setIndex","numberOfTriangles","newIndices","getX","newGeometry","clone","clearGroups","manager","super","dracoLoader","ktx2Loader","meshoptDecoder","pluginCallbacks","register","parser","GLTFTextureBasisUExtension","GLTFTextureWebPExtension","GLTFTextureAVIFExtension","GLTFMaterialsEmissiveStrengthExtension","GLTFMeshoptCompression","onLoad","onProgress","onError","scope","resourcePath","path","relativeUrl","extractUrlBase","resolveURL","itemStart","_onError","e","itemError","itemEnd","loader","setPath","setResponseType","setRequestHeader","requestHeader","setWithCredentials","withCredentials","load","parse","gltf","Error","callback","indexOf","splice","json","extensions","plugins","textDecoder","TextDecoder","JSON","ArrayBuffer","magic","decode","Uint8Array","BINARY_EXTENSION_HEADER_MAGIC","EXTENSIONS","KHR_BINARY_GLTF","GLTFBinaryExtension","content","asset","version","crossOrigin","fileLoader","plugin","extensionsUsed","extensionName","extensionsRequired","KHR_MATERIALS_UNLIT","KHR_DRACO_MESH_COMPRESSION","KHR_TEXTURE_TRANSFORM","GLTFTextureTransformExtension","KHR_MESH_QUANTIZATION","GLTFMeshQuantizationExtension","setExtensions","setPlugins","Promise","resolve","reject","GLTFRegistry","objects","object","remove","removeAll","KHR_LIGHTS_PUNCTUAL","KHR_MATERIALS_CLEARCOAT","KHR_MATERIALS_DISPERSION","KHR_MATERIALS_IOR","KHR_MATERIALS_SHEEN","KHR_MATERIALS_SPECULAR","KHR_MATERIALS_TRANSMISSION","KHR_MATERIALS_IRIDESCENCE","KHR_MATERIALS_ANISOTROPY","KHR_MATERIALS_VOLUME","KHR_TEXTURE_BASISU","KHR_MATERIALS_EMISSIVE_STRENGTH","EXT_MATERIALS_BUMP","EXT_TEXTURE_WEBP","EXT_TEXTURE_AVIF","EXT_MESHOPT_COMPRESSION","EXT_MESH_GPU_INSTANCING","cache","refs","uses","nodeDefs","nodes","nodeIndex","nodeLength","nodeDef","_addNodeRef","lightIndex","cacheKey","dependency","lightDefs","lights","lightDef","lightNode","setRGB","range","type","target","distance","spot","innerConeAngle","outerConeAngle","Math","PI","angle","penumbra","decay","assignExtrasToUserData","createUniqueName","_loadLight","self","then","_getNodeRef","materialParams","materialDef","pending","opacity","metallicRoughness","pbrMetallicRoughness","Array","isArray","baseColorFactor","array","baseColorTexture","assignTexture","all","materialIndex","materials","emissiveStrength","emissiveIntensity","extension","clearcoatFactor","clearcoat","clearcoatTexture","clearcoatRoughnessFactor","clearcoatRoughness","clearcoatRoughnessTexture","clearcoatNormalTexture","scale","clearcoatNormalScale","dispersion","iridescenceFactor","iridescence","iridescenceTexture","iridescenceIor","iridescenceIOR","iridescenceThicknessRange","iridescenceThicknessMinimum","iridescenceThicknessMaximum","iridescenceThicknessTexture","sheenColor","sheenRoughness","sheen","sheenColorFactor","colorFactor","sheenRoughnessFactor","sheenColorTexture","sheenRoughnessTexture","transmissionFactor","transmission","transmissionTexture","thickness","thicknessFactor","thicknessTexture","attenuationDistance","Infinity","colorArray","attenuationColor","ior","specularIntensity","specularFactor","specularTexture","specularColorFactor","specularColor","specularColorTexture","bumpScale","bumpFactor","bumpTexture","anisotropyStrength","anisotropy","anisotropyRotation","anisotropyTexture","textureIndex","textureDef","textures","options","loadTextureImage","source","isSupported","images","textureLoader","uri","handler","getHandler","detectSupport","loadTexture","image","Image","onload","onerror","bufferView","bufferViews","extensionDef","buffer","getDependency","decoder","supported","res","byteOffset","byteLength","stride","byteStride","decodeGltfBufferAsync","mode","filter","ready","result","decodeGltfBuffer","mesh","meshDef","meshes","primitive","primitives","WEBGL_CONSTANTS","TRIANGLES","TRIANGLE_STRIP","TRIANGLE_FAN","attributesDef","attributes","accessor","createNodeMesh","results","nodeObject","pop","isGroup","children","instancedMeshes","m","p","q","s","instancedMesh","TRANSLATION","fromBufferAttribute","ROTATION","SCALE","setMatrixAt","compose","attributeName","attr","instanceColor","itemSize","normalized","setAttribute","copy","call","assignFinalMaterial","clear","BINARY_EXTENSION_HEADER_LENGTH","BINARY_EXTENSION_CHUNK_TYPES","BIN","headerView","DataView","header","slice","getUint32","chunkContentsLength","chunkView","chunkIndex","chunkLength","chunkType","contentArray","preload","bufferViewIndex","gltfAttributeMap","threeAttributeMap","attributeNormalizedMap","attributeTypeMap","threeAttributeName","ATTRIBUTES","toLowerCase","accessorDef","accessors","componentType","WEBGL_COMPONENT_TYPES","decodeDracoFile","attribute","texture","transform","texCoord","channel","offset","fromArray","repeat","needsUpdate","parameterPositions","sampleValues","sampleSize","resultBuffer","values","valueSize","i1","t0","t","t1","stride2","stride3","td","pp","ppp","offset1","offset0","s2","s3","s0","s1","p0","m0","p1","m1","_q","GLTFCubicSplineQuaternionInterpolant","interpolate_","normalize","toArray","FLOAT","FLOAT_MAT3","FLOAT_MAT4","FLOAT_VEC2","FLOAT_VEC3","FLOAT_VEC4","LINEAR","REPEAT","SAMPLER_2D","POINTS","LINES","LINE_LOOP","LINE_STRIP","UNSIGNED_BYTE","UNSIGNED_SHORT","5120","Int8Array","5121","5122","Int16Array","5123","Uint16Array","5125","Uint32Array","5126","Float32Array","WEBGL_FILTERS","9728","9729","9984","9985","9986","9987","WEBGL_WRAPPINGS","33071","33648","10497","WEBGL_TYPE_SIZES","POSITION","NORMAL","TANGENT","TEXCOORD_0","TEXCOORD_1","TEXCOORD_2","TEXCOORD_3","COLOR_0","WEIGHTS_0","JOINTS_0","PATH_PROPERTIES","translation","weights","INTERPOLATION","CUBICSPLINE","STEP","ALPHA_MODES","OPAQUE","MASK","BLEND","createDefaultMaterial","emissive","metalness","roughness","transparent","depthTest","side","addUnknownExtensionsToUserData","knownExtensions","objectDef","userData","gltfExtensions","gltfDef","extras","Object","assign","addMorphTargets","targets","hasMorphPosition","hasMorphNormal","hasMorphColor","il","pendingPositionAccessors","pendingNormalAccessors","pendingColorAccessors","pendingAccessor","normal","morphPositions","morphNormals","morphColors","morphAttributes","morphTargetsRelative","updateMorphTargets","morphTargetInfluences","targetNames","morphTargetDictionary","createPrimitiveKey","primitiveDef","geometryKey","dracoExtension","createAttributesKey","attributesKey","keys","sort","getNormalizedComponentScale","constructor","getImageURIMimeType","search","_identityMatrix","associations","Map","primitiveCache","nodeCache","meshCache","cameraCache","lightCache","sourceCache","textureCache","nodeNamesUsed","isSafari","isFirefox","firefoxVersion","navigator","test","userAgent","match","createImageBitmap","setCrossOrigin","_invokeAll","ext","_markDefs","beforeRoot","getDependencies","dependencies","scenes","animations","cameras","afterRoot","updateMatrixWorld","catch","skinDefs","skins","meshDefs","skinIndex","skinLength","joints","isBone","skin","isSkinnedMesh","ref","updateMappings","original","mappings","child","func","unshift","loadScene","_invokeOne","loadNode","loadMesh","loadAccessor","loadBufferView","loadBuffer","loadMaterial","loadSkin","loadAnimation","loadCamera","defs","map","def","bufferIndex","bufferDef","buffers","bufferViewDef","accessorIndex","sparse","TypedArray","pendingBufferViews","elementBytes","BYTES_PER_ELEMENT","itemBytes","bufferAttribute","ibSlice","floor","ibCacheKey","ib","itemSizeIndices","SCALAR","TypedArrayIndices","byteOffsetIndices","byteOffsetValues","sparseIndices","sparseValues","setX","setY","setZ","setW","sourceIndex","sourceDef","sampler","promise","loadImageSource","flipY","startsWith","samplers","magFilter","minFilter","wrapS","wrapT","webkitURL","sourceURI","isObjectURL","Blob","mimeType","isImageBitmapLoader","imageBitmap","revokeObjectURL","mapName","mapDef","colorSpace","gltfReference","extendTexture","useDerivativeTangents","tangent","useVertexColors","useFlatShading","isPoints","uuid","pointsMaterial","sizeAttenuation","isLine","lineMaterial","cachedMaterial","vertexColors","flatShading","normalScale","materialType","materialExtensions","kmuExtension","getMaterialType","extendParams","metallicFactor","roughnessFactor","metallicRoughnessTexture","extendMaterialParams","doubleSided","alphaMode","depthWrite","alphaTest","alphaCutoff","normalTexture","occlusionTexture","strength","aoMapIntensity","emissiveFactor","emissiveTexture","originalName","sanitizedName","sanitizeNodeName","createDracoPrimitive","decodePrimitive","addPrimitiveAttributes","cached","geometryPromise","meshIndex","loadGeometries","geometries","normalizeSkinWeights","group","cameraIndex","cameraDef","radToDeg","yfov","aspectRatio","znear","zfar","xmag","ymag","skinDef","_loadNodeShallow","inverseBindMatrices","jointNodes","bones","boneInverses","jointNode","mat","animationIndex","animationDef","animationName","pendingNodes","pendingInputAccessors","pendingOutputAccessors","pendingSamplers","pendingTargets","channels","node","input","parameters","output","inputAccessors","outputAccessors","tracks","inputAccessor","outputAccessor","updateMatrix","createdTracks","_createAnimationTracks","traverse","o","isMesh","nodePending","childPending","childrenDef","skeletonPending","skeleton","bind","nodeName","meshPromise","createNodeAttachment","matrix","applyMatrix4","quaternion","has","sceneIndex","sceneDef","nodeIds","reduceAssociations","reducedAssociations","targetName","TypedKeyframeTrack","interpolation","outputArray","_getArrayFromAccessor","j","jl","track","_createCubicSplineTrackInterpolant","scaled","createInterpolant","interpolantType","times","getValueSize","isInterpolantFactoryMethodGLTFCubicSpline","computeBounds","box","min","max","boxScale","multiplyScalar","maxDisplacement","vector","abs","expandByVector","boundingBox","sphere","getCenter","center","radius","distanceTo","boundingSphere","assignAttributeAccessor","gltfAttributeName","workingColorSpace","GLTFLoader","$TypeError","TypeError","module","exports","passed","required","getAll","$has"],"mappings":"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","file":"js/threejs.f2851565.js","sourcesContent":["var render = function render(){var _vm=this,_c=_vm._self._c;return _c('div',{staticClass:\"wrapper pa-4\"},[_c('h1',[_vm._v(\"立方体放在文字段落的中间\")]),_vm._m(0),_c('highlightjs',{staticClass:\"mt-4\",attrs:{\"code\":`#c {\n  float: left;\n  margin: 5px;\n  width: 300px;\n  height: 150px;\n}`,\"language\":'css'}})],1)\n}\nvar staticRenderFns = [function (){var _vm=this,_c=_vm._self._c;return _c('p',[_vm._v(\" Lorem ipsum dolor sit amet, consectetur adipisicing elit. Consequatur, assumenda minus, tempora sit minima voluptates labore illo voluptas numquam libero praesentium soluta odit quo, qui fugit tenetur quos! Perferendis, eligendi? Lorem ipsum dolor sit amet, consectetur adipisicing elit. Consequatur, assumenda minus, tempora sit minima voluptates labore illo voluptas numquam libero praesentium soluta odit quo, qui fugit tenetur quos! Perferendis, eligendi? \"),_c('canvas',{attrs:{\"id\":\"c\"}}),_vm._v(\" Lorem, ipsum dolor sit amet consectetur adipisicing elit. Natus minus amet, porro molestiae quaerat rerum, sunt maxime excepturi corrupti delectus facilis voluptatibus itaque ipsa placeat dolore quas? Rerum, sit quasi. Lorem, ipsum dolor sit amet consectetur adipisicing elit. Natus minus amet, porro molestiae quaerat rerum, sunt maxime excepturi corrupti delectus facilis voluptatibus itaque ipsa placeat dolore quas? Rerum, sit quasi. \")])\n}]\n\nexport { render, staticRenderFns }","<template>\n  <div\n    class=\"wrapper pa-4\"\n  >\n    <h1>立方体放在文字段落的中间</h1>\n    <p>\n      Lorem ipsum dolor sit amet, consectetur adipisicing elit. Consequatur, assumenda minus, tempora sit minima voluptates labore illo voluptas numquam libero praesentium soluta odit quo, qui fugit tenetur quos! Perferendis, eligendi?\n      Lorem ipsum dolor sit amet, consectetur adipisicing elit. Consequatur, assumenda minus, tempora sit minima voluptates labore illo voluptas numquam libero praesentium soluta odit quo, qui fugit tenetur quos! Perferendis, eligendi?\n      <canvas\n        id=\"c\"\n      />\n      Lorem, ipsum dolor sit amet consectetur adipisicing elit. Natus minus amet, porro molestiae quaerat rerum, sunt maxime excepturi corrupti delectus facilis voluptatibus itaque ipsa placeat dolore quas? Rerum, sit quasi.\n      Lorem, ipsum dolor sit amet consectetur adipisicing elit. Natus minus amet, porro molestiae quaerat rerum, sunt maxime excepturi corrupti delectus facilis voluptatibus itaque ipsa placeat dolore quas? Rerum, sit quasi.\n    </p>\n\n    <highlightjs\n      class=\"mt-4\"\n      :code=\"`#c {\n  float: left;\n  margin: 5px;\n  width: 300px;\n  height: 150px;\n}`\"\n      :language=\"'css'\"\n    />\n  </div>\n</template>\n\n<script type=\"module\">\nimport * as THREE from 'three';\n\nexport default {\n  data() {\n    return {\n      fov: 75, // 相机视野范围\n      aspect: 2, // 画布的宽高比 在默认情况下 canvas画布是300x150像素，所以宽高比为300/150或者说2\n      near: 0.1, // 相机近平面\n      far: 5, // 相机远平面\n\n      boxWidth: 1,\n      boxHeight: 1,\n      boxDepth: 1,\n    };\n  },\n  mounted() {\n    this.main();\n  },\n  methods: {\n    main() {\n      const canvas = document.querySelector('#c');\n      const renderer = new THREE.WebGLRenderer({antialias: true, canvas});\n      const {fov, aspect, near, far} = this;\n      const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);\n      console.log(renderer, 'renderer 1', camera, 'camera 1');\n\n      // 摄像机默认指向Z轴负方向，上方向朝向Y轴正方向。我们将会把立方体放置在坐标原点，所以我们需要往后移一下摄像机才能显示出物体\n      camera.position.x = 0;\n      camera.position.z = 3;\n      camera.position.y = 0.8;\n\n      // 然后我们创建一个场景(Scene)。\n      const scene = new THREE.Scene();\n\n      // 然后创建一个包含盒子信息的立方几何体(BoxGeometry)。几乎所有希望在three.js中显示的物体都需要一个包含了组成三维物体的顶点信息的几何体。\n      const {boxWidth, boxHeight, boxDepth} = this;\n      const geometry = new THREE.BoxGeometry(boxWidth, boxHeight, boxDepth);\n      // 然后创建一个基本的材质并设置它的颜色. 颜色的值可以用css方式和十六进制来表示。\n      // const material = new THREE.MeshBasicMaterial({color: 0x44aa88});\n      const material = new THREE.MeshPhongMaterial({\n        color: 0x44aa88, // 绿蓝色 受灯光影响的MeshPhongMaterial材质\n      });\n      // 再创建一个网格(Mesh)对象，它包含了 geometry(几何体 物体的形状) material(材质 如何绘制物体，光滑还是平整，什么颜色，什么贴图..)\n      const cube = new THREE.Mesh(geometry, material);\n      // 修改位置\n      cube.position.x = -0.5;\n      cube.position.y = 1.8;\n      cube.position.z = -1.8;\n      \n\n      // 最后我们将网格添加到场景中。\n      scene.add(cube);\n      // 之后将场景和摄像机传递给渲染器来渲染出整个场景。\n      renderer.render(scene, camera);\n\n      // 立方体旋转\n      function render(time) {\n        time *= 0.001;  // 将时间单位变为秒\n      \n        cube.rotation.x = time;\n        cube.rotation.y = time;\n\n        cubes.forEach((cube, ndx) => {\n          const speed = 1 + ndx * .1;\n          const rot = time * speed;\n          cube.rotation.x = rot;\n          cube.rotation.y = rot;\n        });\n      \n        renderer.render(scene, camera);\n      \n        requestAnimationFrame(render);\n      }\n      requestAnimationFrame(render);\n\n      // 灯光\n      const color = 0xFFFFFF;\n      const intensity = 3;\n      const light = new THREE.DirectionalLight(color, intensity);\n      light.position.set(-1, 2, 4); // 位置\n      scene.add(light);\n\n      function makeInstance(geometry, color, x) {\n        const material = new THREE.MeshPhongMaterial({color});\n      \n        const cube = new THREE.Mesh(geometry, material);\n        scene.add(cube);\n      \n        cube.position.x = x;\n      \n        return cube;\n      }\n\n      const cubes = [\n        makeInstance(geometry, 0x44aa88,  0),\n        makeInstance(geometry, 0x8844aa, -2),\n        makeInstance(geometry, 0xaa8844,  2),\n      ];\n      scene.add(cubes);\n\n    },\n  }\n}\n</script>\n\n<style scoped>\n.wrapper {\n  display: grid;\n  grid-template-columns:\n    1fr\n    min(65ch, 100%)\n    1fr;\n}\n\n.wrapper > * {\n  grid-column: 2;\n}\n\n.full-bleed {\n  width: 100%;\n  grid-column: 1 / -1;\n}\n\n#c {\n  float: left;\n  margin: 5px;\n  width: 300px;\n  height: 150px;\n}\n\n</style>","import mod from \"-!../../../../../node_modules/cache-loader/dist/cjs.js??ref--13-0!../../../../../node_modules/thread-loader/dist/cjs.js!../../../../../node_modules/babel-loader/lib/index.js!../../../../../node_modules/cache-loader/dist/cjs.js??ref--1-0!../../../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./threejs3.vue?vue&type=script&lang=js\"; export default mod; export * from \"-!../../../../../node_modules/cache-loader/dist/cjs.js??ref--13-0!../../../../../node_modules/thread-loader/dist/cjs.js!../../../../../node_modules/babel-loader/lib/index.js!../../../../../node_modules/cache-loader/dist/cjs.js??ref--1-0!../../../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./threejs3.vue?vue&type=script&lang=js\"","import { render, staticRenderFns } from \"./threejs3.vue?vue&type=template&id=e07d5e7e&scoped=true\"\nimport script from \"./threejs3.vue?vue&type=script&lang=js\"\nexport * from \"./threejs3.vue?vue&type=script&lang=js\"\nimport style0 from \"./threejs3.vue?vue&type=style&index=0&id=e07d5e7e&prod&scoped=true&lang=css\"\n\n\n/* normalize component */\nimport normalizer from \"!../../../../../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  \"e07d5e7e\",\n  null\n  \n)\n\nexport default component.exports","export * from \"-!../../../../../node_modules/mini-css-extract-plugin/dist/loader.js??ref--7-oneOf-1-0!../../../../../node_modules/css-loader/dist/cjs.js??ref--7-oneOf-1-1!../../../../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../../../../node_modules/postcss-loader/src/index.js??ref--7-oneOf-1-2!../../../../../node_modules/cache-loader/dist/cjs.js??ref--1-0!../../../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./threejs2.vue?vue&type=style&index=0&id=7e611231&prod&scoped=true&lang=css\"","var render = function render(){var _vm=this,_c=_vm._self._c;return _vm._m(0)\n}\nvar staticRenderFns = [function (){var _vm=this,_c=_vm._self._c;return _c('div',{},[_c('canvas',{attrs:{\"id\":\"c\"}})])\n}]\n\nexport { render, staticRenderFns }","<template>\n  <div\n    class=\"\"\n  >\n    <canvas\n      id=\"c\"\n    />\n  </div>\n</template>\n\n<script type=\"module\">\nimport * as THREE from 'three';\n\nexport default {\n  data() {\n    return {\n      fov: 75, // 相机视野范围\n      aspect: 2, // 画布的宽高比 在默认情况下 canvas画布是300x150像素，所以宽高比为300/150或者说2\n      near: 0.1, // 相机近平面\n      far: 5, // 相机远平面\n\n      boxWidth: 1,\n      boxHeight: 1,\n      boxDepth: 1,\n    };\n  },\n  mounted() {\n    this.main();\n  },\n  methods: {\n    main() {\n      const canvas = document.querySelector('#c');\n      const renderer = new THREE.WebGLRenderer({antialias: true, canvas});\n      const {fov, aspect, near, far} = this;\n      const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);\n      console.log(renderer, 'renderer 1', camera, 'camera 1');\n\n      // 摄像机默认指向Z轴负方向，上方向朝向Y轴正方向。我们将会把立方体放置在坐标原点，所以我们需要往后移一下摄像机才能显示出物体\n      camera.position.x = 0;\n      camera.position.z = 3;\n      camera.position.y = 0.8;\n\n      // 然后我们创建一个场景(Scene)。\n      const scene = new THREE.Scene();\n\n      // 然后创建一个包含盒子信息的立方几何体(BoxGeometry)。几乎所有希望在three.js中显示的物体都需要一个包含了组成三维物体的顶点信息的几何体。\n      const {boxWidth, boxHeight, boxDepth} = this;\n      const geometry = new THREE.BoxGeometry(boxWidth, boxHeight, boxDepth);\n      // 然后创建一个基本的材质并设置它的颜色. 颜色的值可以用css方式和十六进制来表示。\n      // const material = new THREE.MeshBasicMaterial({color: 0x44aa88});\n      const material = new THREE.MeshPhongMaterial({\n        color: 0x44aa88, // 绿蓝色 受灯光影响的MeshPhongMaterial材质\n      });\n      // 再创建一个网格(Mesh)对象，它包含了 geometry(几何体 物体的形状) material(材质 如何绘制物体，光滑还是平整，什么颜色，什么贴图..)\n      const cube = new THREE.Mesh(geometry, material);\n      // 修改位置\n      cube.position.x = -0.5;\n      cube.position.y = 1.8;\n      cube.position.z = -1.8;\n      \n\n      // 最后我们将网格添加到场景中。\n      scene.add(cube);\n      // 之后将场景和摄像机传递给渲染器来渲染出整个场景。\n      renderer.render(scene, camera);\n\n      function resizeRendererToDisplaySize(renderer) {\n        const canvas = renderer.domElement;\n        const width = canvas.clientWidth;\n        const height = canvas.clientHeight;\n        const needResize = canvas.width !== width || canvas.height !== height;\n        if (needResize) {\n          renderer.setSize(width, height, false);\n        }\n        return needResize;\n      }\n\n      // 立方体旋转\n      function render(time) {\n        time *= 0.001;  // 将时间单位变为秒\n\n\n        // 注意如果我们的canvas大小被调整了那函数会返回true。我们可以利用 这个来检查是否有其他的东西应该更新。我们修改渲染循环 来使用我们的新函数\n        if (resizeRendererToDisplaySize(renderer)) {\n          const canvas = renderer.domElement;\n          camera.aspect = canvas.clientWidth / canvas.clientHeight;\n          camera.updateProjectionMatrix();\n        }\n\n        // 我们先解决拉伸的问题。为此我们要将相机的宽高比设置为canvas的宽高比。 我们可以通过canvas的clientWidth和clientHeight属性来实现。\n        const canvas = renderer.domElement;\n        camera.aspect = canvas.clientWidth / canvas.clientHeight;\n        camera.updateProjectionMatrix();\n      \n        cube.rotation.x = time;\n        cube.rotation.y = time;\n\n        cubes.forEach((cube, ndx) => {\n          const speed = 1 + ndx * .1;\n          const rot = time * speed;\n          cube.rotation.x = rot;\n          cube.rotation.y = rot;\n        });\n      \n        renderer.render(scene, camera);\n      \n        requestAnimationFrame(render);\n      }\n      requestAnimationFrame(render);\n\n      // 灯光\n      const color = 0xFFFFFF;\n      const intensity = 3;\n      const light = new THREE.DirectionalLight(color, intensity);\n      light.position.set(-1, 2, 4); // 位置\n      scene.add(light);\n\n      function makeInstance(geometry, color, x) {\n        const material = new THREE.MeshPhongMaterial({color});\n      \n        const cube = new THREE.Mesh(geometry, material);\n        scene.add(cube);\n      \n        cube.position.x = x;\n      \n        return cube;\n      }\n\n      const cubes = [\n        makeInstance(geometry, 0x44aa88,  0),\n        makeInstance(geometry, 0x8844aa, -2),\n        makeInstance(geometry, 0xaa8844,  2),\n      ];\n      scene.add(cubes);\n\n    },\n  }\n}\n</script>\n\n<style scoped>\n/* HTML中的body默认有5个像素的margin值所以设置margin为0来移除margin值。 设置html和body的高度为100%让他们充满整个窗口。不然的话他们的大小只会 和填充他们的内容一样。\n\n然后我们让id=c的元素的尺寸是容器的100%这里是body标签。\n\n最后我们设置它的display为block。canvas的display默认为 inline。行内元素的末尾会有空格。 通过设置canvas为块级元素就能消除这个空格。 */\nhtml, body {\n  margin: 0;\n  height: 100%;\n}\n#c {\n  width: 100%;\n  height: 100%;\n  display: block;\n}\n</style>","import mod from \"-!../../../../../node_modules/cache-loader/dist/cjs.js??ref--13-0!../../../../../node_modules/thread-loader/dist/cjs.js!../../../../../node_modules/babel-loader/lib/index.js!../../../../../node_modules/cache-loader/dist/cjs.js??ref--1-0!../../../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./threejs2.vue?vue&type=script&lang=js\"; export default mod; export * from \"-!../../../../../node_modules/cache-loader/dist/cjs.js??ref--13-0!../../../../../node_modules/thread-loader/dist/cjs.js!../../../../../node_modules/babel-loader/lib/index.js!../../../../../node_modules/cache-loader/dist/cjs.js??ref--1-0!../../../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./threejs2.vue?vue&type=script&lang=js\"","import { render, staticRenderFns } from \"./threejs2.vue?vue&type=template&id=7e611231&scoped=true\"\nimport script from \"./threejs2.vue?vue&type=script&lang=js\"\nexport * from \"./threejs2.vue?vue&type=script&lang=js\"\nimport style0 from \"./threejs2.vue?vue&type=style&index=0&id=7e611231&prod&scoped=true&lang=css\"\n\n\n/* normalize component */\nimport normalizer from \"!../../../../../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  \"7e611231\",\n  null\n  \n)\n\nexport default component.exports","var render = function render(){var _vm=this,_c=_vm._self._c;return _c('div',{staticClass:\"wrapper pa-4\"},[_c('h1',[_vm._v(\"threejs canvas截图\")]),_vm._m(0),_c('p',[_vm._v(\" 截图需要把render函数提出来 在截图前render函数执行一次 \"),_c('canvas',{staticStyle:{\"border\":\"1px solid\",\"width\":\"100%\",\"max-height\":\"20vh\"},attrs:{\"id\":\"c3\"}}),_c('v-btn',{staticClass:\"my-2\",on:{\"click\":_vm.screenShotDownload}},[_vm._v(\" 截图并下载 \")]),_c('v-btn',{staticClass:\"my-2\",on:{\"click\":_vm.screenShot}},[_vm._v(\" 截图 \")]),_c('img',{staticStyle:{\"display\":\"none\"},attrs:{\"id\":\"img\",\"src\":\"\",\"alt\":\"截图\"}}),_c('highlightjs',{staticClass:\"mt-4\",attrs:{\"code\":`screenShotDownload() {\n  const saveBlob = (function() {\n  const a = document.createElement('a');\n    document.body.appendChild(a);\n    a.style.display = 'none';\n    return function saveData(blob, fileName) {\n      const url = window.URL.createObjectURL(blob);\n      a.href = url;\n      a.download = fileName;\n      a.click();\n    };\n  }());\n\n  this.render3();\n  const canvas = document.getElementById('c3');\n  canvas.toBlob((blob) => {\n    saveBlob(blob, 'screencapture.png');\n  });\n},\nscreenShot() {\n  this.render3();\n  const canvas = document.getElementById('c3');\n  const img = document.getElementById('img');\n  const url = canvas.toDataURL();\n  img.src = url;\n  img.style.display = 'block';\n},`,\"language\":'js'}})],1)])\n}\nvar staticRenderFns = [function (){var _vm=this,_c=_vm._self._c;return _c('p',[_vm._v(\" 首先自适应宽度 根据canvas的实际宽高来渲染并不会导致失真 \"),_c('canvas',{staticStyle:{\"border\":\"1px solid\",\"width\":\"100%\",\"max-height\":\"20vh\"},attrs:{\"id\":\"c2\"}})])\n}]\n\nexport { render, staticRenderFns }","<template>\n  <div\n    class=\"wrapper pa-4\"\n  >\n    <h1>threejs canvas截图</h1>\n    <p>\n      首先自适应宽度 根据canvas的实际宽高来渲染并不会导致失真\n      <canvas\n        id=\"c2\"\n        style=\"border: 1px solid;width: 100%;max-height: 20vh\"\n      />\n    </p>\n    <p>\n      截图需要把render函数提出来 在截图前render函数执行一次\n      <canvas\n        id=\"c3\"\n        style=\"border: 1px solid;width: 100%;max-height: 20vh\"\n      />\n      <v-btn\n        class=\"my-2\"\n        @click=\"screenShotDownload\"\n      >\n        截图并下载\n      </v-btn>\n      <v-btn\n        class=\"my-2\"\n        @click=\"screenShot\"\n      >\n        截图\n      </v-btn>\n      <img\n        id=\"img\"\n        src=\"\"\n        alt=\"截图\"\n        style=\"display: none;\"\n      >\n      <highlightjs\n        class=\"mt-4\"\n        :code=\"`screenShotDownload() {\n  const saveBlob = (function() {\n  const a = document.createElement('a');\n    document.body.appendChild(a);\n    a.style.display = 'none';\n    return function saveData(blob, fileName) {\n      const url = window.URL.createObjectURL(blob);\n      a.href = url;\n      a.download = fileName;\n      a.click();\n    };\n  }());\n\n  this.render3();\n  const canvas = document.getElementById('c3');\n  canvas.toBlob((blob) => {\n    saveBlob(blob, 'screencapture.png');\n  });\n},\nscreenShot() {\n  this.render3();\n  const canvas = document.getElementById('c3');\n  const img = document.getElementById('img');\n  const url = canvas.toDataURL();\n  img.src = url;\n  img.style.display = 'block';\n},`\"\n        :language=\"'js'\"\n      />\n    </p>\n  </div>\n</template>\n\n<script type=\"module\">\nimport * as THREE from 'three';\n\nexport default {\n  data() {\n    return {\n\n      state3: {\n        time: 0,\n      },\n      renderer3: null,\n      scene: null,\n      camera: null,\n      cube: null,\n    };\n  },\n  mounted() {\n    this.main2();\n    this.init3();\n\n    this.animate3();\n    requestAnimationFrame(this.animate3);\n  },\n  methods: {\n    main2() {\n      // canvas\n      const canvas = document.querySelector('#c2');\n      // 渲染器 antialias代表是否开启抗锯齿\n      const renderer = new THREE.WebGLRenderer({antialias: true, canvas});\n      const camera = new THREE.PerspectiveCamera(75, 2, 0.1, 5);\n\n      // 摄像机位置\n      camera.position.x = 0;\n      camera.position.z = 3;\n      camera.position.y = 0.5;\n\n      // 创建场景\n      const scene = new THREE.Scene();\n\n      // 几何体 宽 高 深\n      const geometry = new THREE.BoxGeometry(1, 1, 2);\n\n      // 材质\n      const material = new THREE.MeshPhongMaterial({\n        color: '#FFDD11',\n      });\n\n      // 再创建一个网格(Mesh)对象，它包含了 geometry(几何体 物体的形状) material(材质 如何绘制物体，光滑还是平整，什么颜色，什么贴图..)\n      const cube = new THREE.Mesh(geometry, material);\n      \n      // 最后我们将网格添加到场景中。\n      scene.add(cube);\n      // 之后将场景和摄像机传递给渲染器来渲染出整个场景。\n      renderer.render(scene, camera);\n\n      // 灯光\n      const color = 0xFFFFFF;\n      const intensity = 3;\n      const light = new THREE.DirectionalLight(color, intensity);\n      light.position.set(-1, 2, 4); // 位置\n      scene.add(light);\n\n      // 判断画布是否需要调整大小\n      function resizeRendererToDisplaySize(renderer) {\n        const canvas = renderer.domElement;\n        const width = canvas.clientWidth;\n        const height = canvas.clientHeight;\n        const needResize = canvas.width !== width || canvas.height !== height;\n        if (needResize) {\n          renderer.setSize(width, height, false);\n        }\n        return needResize;\n      }\n\n      // 立方体旋转\n      function render(time) {\n        time *= 0.001;  // 将时间单位变为秒\n\n        // 注意如果我们的canvas大小被调整了那函数会返回true。我们可以利用 这个来检查是否有其他的东西应该更新。我们修改渲染循环 来使用我们的新函数\n        if (resizeRendererToDisplaySize(renderer)) {\n          const canvas = renderer.domElement;\n          camera.aspect = canvas.clientWidth / canvas.clientHeight;\n          camera.updateProjectionMatrix();\n        }\n      \n        cube.rotation.x = time;\n        cube.rotation.y = time;\n      \n        renderer.render(scene, camera);\n      \n        requestAnimationFrame(render);\n      }\n      requestAnimationFrame(render);\n    },\n    init3() {\n      // canvas\n      const canvas = document.querySelector('#c3');\n      // 渲染器 antialias代表是否开启抗锯齿\n      this.renderer = new THREE.WebGLRenderer({antialias: true, canvas});\n      this.camera = new THREE.PerspectiveCamera(75, 2, 0.1, 5);\n\n      // 摄像机位置\n      this.camera.position.x = 0;\n      this.camera.position.z = 3;\n      this.camera.position.y = 0.5;\n\n      // 创建场景\n      this.scene = new THREE.Scene();\n\n      // 几何体 宽 高 深\n      const geometry = new THREE.BoxGeometry(1, 1, 2);\n\n      // 材质\n      const material = new THREE.MeshPhongMaterial({\n        color: '#33DDee',\n      });\n\n      // 再创建一个网格(Mesh)对象，它包含了 geometry(几何体 物体的形状) material(材质 如何绘制物体，光滑还是平整，什么颜色，什么贴图..)\n      this.cube = new THREE.Mesh(geometry, material);\n      \n      // 最后我们将网格添加到场景中。\n      this.scene.add(this.cube);\n      // 之后将场景和摄像机传递给渲染器来渲染出整个场景。\n      this.renderer.render(this.scene, this.camera);\n\n      // 灯光\n      const color = 0xFFFFFF;\n      const intensity = 3;\n      const light = new THREE.DirectionalLight(color, intensity);\n      light.position.set(-1, 2, 4); // 位置\n      this.scene.add(light);\n    },\n\n      // 判断画布是否需要调整大小\n    resizeRendererToDisplaySize(renderer) {\n      const canvas = renderer.domElement;\n      const width = canvas.clientWidth;\n      const height = canvas.clientHeight;\n      const needResize = canvas.width !== width || canvas.height !== height;\n      if (needResize) {\n        renderer.setSize(width, height, false);\n      }\n      return needResize;\n    },\n    render3() {\n      const speed = 0.1;\n      const rot = this.state3.time * speed;\n      // 注意如果我们的canvas大小被调整了那函数会返回true。我们可以利用 这个来检查是否有其他的东西应该更新。我们修改渲染循环 来使用我们的新函数\n      if (this.resizeRendererToDisplaySize(this.renderer)) {\n        const canvas = this.renderer.domElement;\n        this.camera.aspect = canvas.clientWidth / canvas.clientHeight;\n        this.camera.updateProjectionMatrix();\n      }\n\n      this.cube.rotation.x = rot;\n      this.cube.rotation.y = rot;\n\n      this.renderer.render(this.scene, this.camera);\n\n      requestAnimationFrame(this.render3);\n    },\n    animate3(time) {\n      this.state3.time = time * 0.01;\n    \n      this.render3();\n    \n      requestAnimationFrame(this.animate3);\n    },\n    screenShotDownload() {\n      const saveBlob = (function() {\n      const a = document.createElement('a');\n        document.body.appendChild(a);\n        a.style.display = 'none';\n        return function saveData(blob, fileName) {\n          const url = window.URL.createObjectURL(blob);\n          a.href = url;\n          a.download = fileName;\n          a.click();\n        };\n      }());\n\n      this.render3();\n      const canvas = document.getElementById('c3');\n      canvas.toBlob((blob) => {\n        saveBlob(blob, `screencapture-${canvas.width}x${canvas.height}.png`);\n      });\n    },\n    screenShot() {\n      this.render3();\n      const canvas = document.getElementById('c3');\n      const img = document.getElementById('img');\n      const url = canvas.toDataURL();\n      img.src = url;\n      img.style.display = 'block';\n    },\n  }\n}\n</script>\n\n<style scoped>\n.wrapper {\n  display: grid;\n  grid-template-columns:\n    1fr\n    min(65ch, 100%)\n    1fr;\n}\n\n.wrapper > * {\n  grid-column: 2;\n}\n\n.full-bleed {\n  width: 100%;\n  grid-column: 1 / -1;\n}\n\n</style>","import mod from \"-!../../../../../node_modules/cache-loader/dist/cjs.js??ref--13-0!../../../../../node_modules/thread-loader/dist/cjs.js!../../../../../node_modules/babel-loader/lib/index.js!../../../../../node_modules/cache-loader/dist/cjs.js??ref--1-0!../../../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./threejs4.vue?vue&type=script&lang=js\"; export default mod; export * from \"-!../../../../../node_modules/cache-loader/dist/cjs.js??ref--13-0!../../../../../node_modules/thread-loader/dist/cjs.js!../../../../../node_modules/babel-loader/lib/index.js!../../../../../node_modules/cache-loader/dist/cjs.js??ref--1-0!../../../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./threejs4.vue?vue&type=script&lang=js\"","import { render, staticRenderFns } from \"./threejs4.vue?vue&type=template&id=7fbec5a2&scoped=true\"\nimport script from \"./threejs4.vue?vue&type=script&lang=js\"\nexport * from \"./threejs4.vue?vue&type=script&lang=js\"\nimport style0 from \"./threejs4.vue?vue&type=style&index=0&id=7fbec5a2&prod&scoped=true&lang=css\"\n\n\n/* normalize component */\nimport normalizer from \"!../../../../../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  \"7fbec5a2\",\n  null\n  \n)\n\nexport default component.exports","'use strict';\nvar DESCRIPTORS = require('../internals/descriptors');\nvar uncurryThis = require('../internals/function-uncurry-this');\nvar defineBuiltInAccessor = require('../internals/define-built-in-accessor');\n\nvar URLSearchParamsPrototype = URLSearchParams.prototype;\nvar forEach = uncurryThis(URLSearchParamsPrototype.forEach);\n\n// `URLSearchParams.prototype.size` getter\n// https://github.com/whatwg/url/pull/734\nif (DESCRIPTORS && !('size' in URLSearchParamsPrototype)) {\n  defineBuiltInAccessor(URLSearchParamsPrototype, 'size', {\n    get: function size() {\n      var count = 0;\n      forEach(this, function () { count++; });\n      return count;\n    },\n    configurable: true,\n    enumerable: true\n  });\n}\n","export * from \"-!../../../../../node_modules/mini-css-extract-plugin/dist/loader.js??ref--7-oneOf-1-0!../../../../../node_modules/css-loader/dist/cjs.js??ref--7-oneOf-1-1!../../../../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../../../../node_modules/postcss-loader/src/index.js??ref--7-oneOf-1-2!../../../../../node_modules/cache-loader/dist/cjs.js??ref--1-0!../../../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./threejs5.vue?vue&type=style&index=0&id=bfebeb9a&prod&scoped=true&lang=css\"","export * from \"-!../../../../../node_modules/mini-css-extract-plugin/dist/loader.js??ref--7-oneOf-1-0!../../../../../node_modules/css-loader/dist/cjs.js??ref--7-oneOf-1-1!../../../../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../../../../node_modules/postcss-loader/src/index.js??ref--7-oneOf-1-2!../../../../../node_modules/cache-loader/dist/cjs.js??ref--1-0!../../../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./threejs6.vue?vue&type=style&index=0&id=34c7ad35&prod&scoped=true&lang=css\"","'use strict';\nvar defineBuiltIn = require('../internals/define-built-in');\nvar uncurryThis = require('../internals/function-uncurry-this');\nvar toString = require('../internals/to-string');\nvar validateArgumentsLength = require('../internals/validate-arguments-length');\n\nvar $URLSearchParams = URLSearchParams;\nvar URLSearchParamsPrototype = $URLSearchParams.prototype;\nvar append = uncurryThis(URLSearchParamsPrototype.append);\nvar $delete = uncurryThis(URLSearchParamsPrototype['delete']);\nvar forEach = uncurryThis(URLSearchParamsPrototype.forEach);\nvar push = uncurryThis([].push);\nvar params = new $URLSearchParams('a=1&a=2&b=3');\n\nparams['delete']('a', 1);\n// `undefined` case is a Chromium 117 bug\n// https://bugs.chromium.org/p/v8/issues/detail?id=14222\nparams['delete']('b', undefined);\n\nif (params + '' !== 'a=2') {\n  defineBuiltIn(URLSearchParamsPrototype, 'delete', function (name /* , value */) {\n    var length = arguments.length;\n    var $value = length < 2 ? undefined : arguments[1];\n    if (length && $value === undefined) return $delete(this, name);\n    var entries = [];\n    forEach(this, function (v, k) { // also validates `this`\n      push(entries, { key: k, value: v });\n    });\n    validateArgumentsLength(length, 1);\n    var key = toString(name);\n    var value = toString($value);\n    var index = 0;\n    var dindex = 0;\n    var found = false;\n    var entriesLength = entries.length;\n    var entry;\n    while (index < entriesLength) {\n      entry = entries[index++];\n      if (found || entry.key === key) {\n        found = true;\n        $delete(this, entry.key);\n      } else dindex++;\n    }\n    while (dindex < entriesLength) {\n      entry = entries[dindex++];\n      if (!(entry.key === key && entry.value === value)) append(this, entry.key, entry.value);\n    }\n  }, { enumerable: true, unsafe: true });\n}\n","export * from \"-!../../../../../node_modules/mini-css-extract-plugin/dist/loader.js??ref--7-oneOf-1-0!../../../../../node_modules/css-loader/dist/cjs.js??ref--7-oneOf-1-1!../../../../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../../../../node_modules/postcss-loader/src/index.js??ref--7-oneOf-1-2!../../../../../node_modules/cache-loader/dist/cjs.js??ref--1-0!../../../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./threejs3.vue?vue&type=style&index=0&id=e07d5e7e&prod&scoped=true&lang=css\"","var render = function render(){var _vm=this,_c=_vm._self._c;return _c('div',{staticClass:\"wrapper pa-4\"},[_c('h1',[_vm._v(\"画线（Drawing lines）\")]),_c('canvas',{staticClass:\"full-bleed\",attrs:{\"id\":\"c\"}}),_c('highlightjs',{staticClass:\"mt-4\",attrs:{\"code\":`//..\n// 线 材质\nconst material1 = new THREE.LineBasicMaterial( { color: 0x0000ff } );\nconst points = [];\npoints.push( new THREE.Vector3( - 10, 0, 0 ) );\npoints.push( new THREE.Vector3( 0, 10, 0 ) );\npoints.push( new THREE.Vector3( 10, 0, 0 ) );\n// 线 几何体\nconst geometry1 = new THREE.BufferGeometry().setFromPoints( points );\nconst line = new THREE.Line( geometry1, material1 );\nscene.add(line);\n//..`,\"language\":'js'}})],1)\n}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","<template>\n  <div\n    class=\"wrapper pa-4\"\n  >\n    <h1>画线（Drawing lines）</h1>\n    <canvas\n      id=\"c\"\n      class=\"full-bleed\"\n    />\n\n    <highlightjs\n      class=\"mt-4\"\n      :code=\"`//..\n// 线 材质\nconst material1 = new THREE.LineBasicMaterial( { color: 0x0000ff } );\nconst points = [];\npoints.push( new THREE.Vector3( - 10, 0, 0 ) );\npoints.push( new THREE.Vector3( 0, 10, 0 ) );\npoints.push( new THREE.Vector3( 10, 0, 0 ) );\n// 线 几何体\nconst geometry1 = new THREE.BufferGeometry().setFromPoints( points );\nconst line = new THREE.Line( geometry1, material1 );\nscene.add(line);\n//..`\"\n      :language=\"'js'\"\n    />\n  </div>\n</template>\n\n<script type=\"module\">\nimport * as THREE from 'three';\n\nexport default {\n  data() {\n    return {\n      fov: 75, // 相机视野范围\n      aspect: 2, // 画布的宽高比 在默认情况下 canvas画布是300x150像素，所以宽高比为300/150或者说2\n      near: 0.1, // 相机近平面\n      far: 5, // 相机远平面\n\n      boxWidth: 1,\n      boxHeight: 1,\n      boxDepth: 1,\n    };\n  },\n  mounted() {\n    this.main();\n  },\n  methods: {\n    main() {\n      // canvas\n      const canvas = document.querySelector('#c');\n      // 渲染器 antialias代表是否开启抗锯齿\n      const renderer = new THREE.WebGLRenderer({antialias: true, canvas});\n      renderer.setSize( window.innerWidth, window.innerHeight - 300, false );\n      const camera = new THREE.PerspectiveCamera(90,  window.innerWidth / window.innerHeight, 1, 500 );\n\n      // 摄像机位置 xyz\n      camera.position.set( 0, 0, 15 );\n      camera.lookAt( 0, 0, -0.2 );\n\n      // 创建场景\n      const scene = new THREE.Scene();\n\n      // 几何体 宽 高 深\n      const geometry = new THREE.BoxGeometry(1, 1, 1);\n\n      // 材质\n      const material = new THREE.MeshPhongMaterial({\n        color: '#FFDD11',\n      });\n\n      // 再创建一个网格(Mesh)对象，它包含了 geometry(几何体 物体的形状) material(材质 如何绘制物体，光滑还是平整，什么颜色，什么贴图..)\n      const cube = new THREE.Mesh(geometry, material);\n      \n      // 最后我们将网格添加到场景中。\n      scene.add(cube);\n\n      // 线 材质\n      const material1 = new THREE.LineBasicMaterial( { color: 0x0000ff } );\n      const points = [];\n      points.push( new THREE.Vector3( - 10, 0, 0 ) );\n      points.push( new THREE.Vector3( 0, 10, 0 ) );\n      points.push( new THREE.Vector3( 10, 0, 0 ) );\n      // 线 几何体\n      const geometry1 = new THREE.BufferGeometry().setFromPoints( points );\n      const line = new THREE.Line( geometry1, material1 );\n      scene.add(line);\n\n      // 之后将场景和摄像机传递给渲染器来渲染出整个场景。\n      renderer.render(scene, camera);\n\n      // 灯光\n      const color = 0xFFFFFF;\n      const intensity = 3;\n      const light = new THREE.DirectionalLight(color, intensity);\n      light.position.set(-1, 2, 4); // 位置\n      scene.add(light);\n\n      // 判断画布是否需要调整大小\n      function resizeRendererToDisplaySize(renderer) {\n        const canvas = renderer.domElement;\n        const width = canvas.clientWidth;\n        const height = canvas.clientHeight;\n        const needResize = canvas.width !== width || canvas.height !== height;\n        if (needResize) {\n          renderer.setSize(width, height, false);\n        }\n        return needResize;\n      }\n\n      // 立方体旋转\n      function render(time) {\n        time *= 0.001;  // 将时间单位变为秒\n\n        // 注意如果我们的canvas大小被调整了那函数会返回true。我们可以利用 这个来检查是否有其他的东西应该更新。我们修改渲染循环 来使用我们的新函数\n        if (resizeRendererToDisplaySize(renderer)) {\n          const canvas = renderer.domElement;\n          camera.aspect = canvas.clientWidth / canvas.clientHeight;\n          camera.updateProjectionMatrix();\n        }\n      \n        cube.rotation.x = time;\n        cube.rotation.y = time;\n      \n        renderer.render(scene, camera);\n      \n        requestAnimationFrame(render);\n      }\n      requestAnimationFrame(render);\n    },\n  }\n}\n</script>\n\n<style scoped>\n.wrapper {\n  display: grid;\n  grid-template-columns:\n    1fr\n    min(65ch, 100%)\n    1fr;\n}\n\n.wrapper > * {\n  grid-column: 2;\n}\n\n.full-bleed {\n  width: 100%;\n  grid-column: 1 / -1;\n}\n\n</style>","import mod from \"-!../../../../../node_modules/cache-loader/dist/cjs.js??ref--13-0!../../../../../node_modules/thread-loader/dist/cjs.js!../../../../../node_modules/babel-loader/lib/index.js!../../../../../node_modules/cache-loader/dist/cjs.js??ref--1-0!../../../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./threejs5.vue?vue&type=script&lang=js\"; export default mod; export * from \"-!../../../../../node_modules/cache-loader/dist/cjs.js??ref--13-0!../../../../../node_modules/thread-loader/dist/cjs.js!../../../../../node_modules/babel-loader/lib/index.js!../../../../../node_modules/cache-loader/dist/cjs.js??ref--1-0!../../../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./threejs5.vue?vue&type=script&lang=js\"","import { render, staticRenderFns } from \"./threejs5.vue?vue&type=template&id=bfebeb9a&scoped=true\"\nimport script from \"./threejs5.vue?vue&type=script&lang=js\"\nexport * from \"./threejs5.vue?vue&type=script&lang=js\"\nimport style0 from \"./threejs5.vue?vue&type=style&index=0&id=bfebeb9a&prod&scoped=true&lang=css\"\n\n\n/* normalize component */\nimport normalizer from \"!../../../../../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  \"bfebeb9a\",\n  null\n  \n)\n\nexport default component.exports","var render = function render(){var _vm=this,_c=_vm._self._c;return _c('div',{staticClass:\"wrapper pa-4\"},[_c('h1',[_vm._v(\"载入3D模型（Loading 3D models）\")]),_c('canvas',{staticClass:\"full-bleed\",attrs:{\"id\":\"c\"}}),_c('highlightjs',{staticClass:\"mt-4\",attrs:{\"code\":`${_vm.code}`,\"language\":'js'}})],1)\n}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","import {\n\tBufferAttribute,\n\tBufferGeometry,\n\tFloat32BufferAttribute,\n\tInstancedBufferAttribute,\n\tInterleavedBuffer,\n\tInterleavedBufferAttribute,\n\tTriangleFanDrawMode,\n\tTriangleStripDrawMode,\n\tTrianglesDrawMode,\n\tVector3,\n} from 'three';\n\nfunction computeMikkTSpaceTangents( geometry, MikkTSpace, negateSign = true ) {\n\n\tif ( ! MikkTSpace || ! MikkTSpace.isReady ) {\n\n\t\tthrow new Error( 'BufferGeometryUtils: Initialized MikkTSpace library required.' );\n\n\t}\n\n\tif ( ! geometry.hasAttribute( 'position' ) || ! geometry.hasAttribute( 'normal' ) || ! geometry.hasAttribute( 'uv' ) ) {\n\n\t\tthrow new Error( 'BufferGeometryUtils: Tangents require \"position\", \"normal\", and \"uv\" attributes.' );\n\n\t}\n\n\tfunction getAttributeArray( attribute ) {\n\n\t\tif ( attribute.normalized || attribute.isInterleavedBufferAttribute ) {\n\n\t\t\tconst dstArray = new Float32Array( attribute.count * attribute.itemSize );\n\n\t\t\tfor ( let i = 0, j = 0; i < attribute.count; i ++ ) {\n\n\t\t\t\tdstArray[ j ++ ] = attribute.getX( i );\n\t\t\t\tdstArray[ j ++ ] = attribute.getY( i );\n\n\t\t\t\tif ( attribute.itemSize > 2 ) {\n\n\t\t\t\t\tdstArray[ j ++ ] = attribute.getZ( i );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn dstArray;\n\n\t\t}\n\n\t\tif ( attribute.array instanceof Float32Array ) {\n\n\t\t\treturn attribute.array;\n\n\t\t}\n\n\t\treturn new Float32Array( attribute.array );\n\n\t}\n\n\t// MikkTSpace algorithm requires non-indexed input.\n\n\tconst _geometry = geometry.index ? geometry.toNonIndexed() : geometry;\n\n\t// Compute vertex tangents.\n\n\tconst tangents = MikkTSpace.generateTangents(\n\n\t\tgetAttributeArray( _geometry.attributes.position ),\n\t\tgetAttributeArray( _geometry.attributes.normal ),\n\t\tgetAttributeArray( _geometry.attributes.uv )\n\n\t);\n\n\t// Texture coordinate convention of glTF differs from the apparent\n\t// default of the MikkTSpace library; .w component must be flipped.\n\n\tif ( negateSign ) {\n\n\t\tfor ( let i = 3; i < tangents.length; i += 4 ) {\n\n\t\t\ttangents[ i ] *= - 1;\n\n\t\t}\n\n\t}\n\n\t//\n\n\t_geometry.setAttribute( 'tangent', new BufferAttribute( tangents, 4 ) );\n\n\tif ( geometry !== _geometry ) {\n\n\t\tgeometry.copy( _geometry );\n\n\t}\n\n\treturn geometry;\n\n}\n\n/**\n * @param  {Array<BufferGeometry>} geometries\n * @param  {Boolean} useGroups\n * @return {BufferGeometry}\n */\nfunction mergeGeometries( geometries, useGroups = false ) {\n\n\tconst isIndexed = geometries[ 0 ].index !== null;\n\n\tconst attributesUsed = new Set( Object.keys( geometries[ 0 ].attributes ) );\n\tconst morphAttributesUsed = new Set( Object.keys( geometries[ 0 ].morphAttributes ) );\n\n\tconst attributes = {};\n\tconst morphAttributes = {};\n\n\tconst morphTargetsRelative = geometries[ 0 ].morphTargetsRelative;\n\n\tconst mergedGeometry = new BufferGeometry();\n\n\tlet offset = 0;\n\n\tfor ( let i = 0; i < geometries.length; ++ i ) {\n\n\t\tconst geometry = geometries[ i ];\n\t\tlet attributesCount = 0;\n\n\t\t// ensure that all geometries are indexed, or none\n\n\t\tif ( isIndexed !== ( geometry.index !== null ) ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// gather attributes, exit early if they're different\n\n\t\tfor ( const name in geometry.attributes ) {\n\n\t\t\tif ( ! attributesUsed.has( name ) ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure \"' + name + '\" attribute exists among all geometries, or in none of them.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tif ( attributes[ name ] === undefined ) attributes[ name ] = [];\n\n\t\t\tattributes[ name ].push( geometry.attributes[ name ] );\n\n\t\t\tattributesCount ++;\n\n\t\t}\n\n\t\t// ensure geometries have the same number of attributes\n\n\t\tif ( attributesCount !== attributesUsed.size ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. Make sure all geometries have the same number of attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// gather morph attributes, exit early if they're different\n\n\t\tif ( morphTargetsRelative !== geometry.morphTargetsRelative ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. .morphTargetsRelative must be consistent throughout all geometries.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tfor ( const name in geometry.morphAttributes ) {\n\n\t\t\tif ( ! morphAttributesUsed.has( name ) ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '.  .morphAttributes must be consistent throughout all geometries.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tif ( morphAttributes[ name ] === undefined ) morphAttributes[ name ] = [];\n\n\t\t\tmorphAttributes[ name ].push( geometry.morphAttributes[ name ] );\n\n\t\t}\n\n\t\tif ( useGroups ) {\n\n\t\t\tlet count;\n\n\t\t\tif ( isIndexed ) {\n\n\t\t\t\tcount = geometry.index.count;\n\n\t\t\t} else if ( geometry.attributes.position !== undefined ) {\n\n\t\t\t\tcount = geometry.attributes.position.count;\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. The geometry must have either an index or a position attribute' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tmergedGeometry.addGroup( offset, count, i );\n\n\t\t\toffset += count;\n\n\t\t}\n\n\t}\n\n\t// merge indices\n\n\tif ( isIndexed ) {\n\n\t\tlet indexOffset = 0;\n\t\tconst mergedIndex = [];\n\n\t\tfor ( let i = 0; i < geometries.length; ++ i ) {\n\n\t\t\tconst index = geometries[ i ].index;\n\n\t\t\tfor ( let j = 0; j < index.count; ++ j ) {\n\n\t\t\t\tmergedIndex.push( index.getX( j ) + indexOffset );\n\n\t\t\t}\n\n\t\t\tindexOffset += geometries[ i ].attributes.position.count;\n\n\t\t}\n\n\t\tmergedGeometry.setIndex( mergedIndex );\n\n\t}\n\n\t// merge attributes\n\n\tfor ( const name in attributes ) {\n\n\t\tconst mergedAttribute = mergeAttributes( attributes[ name ] );\n\n\t\tif ( ! mergedAttribute ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the ' + name + ' attribute.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tmergedGeometry.setAttribute( name, mergedAttribute );\n\n\t}\n\n\t// merge morph attributes\n\n\tfor ( const name in morphAttributes ) {\n\n\t\tconst numMorphTargets = morphAttributes[ name ][ 0 ].length;\n\n\t\tif ( numMorphTargets === 0 ) break;\n\n\t\tmergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};\n\t\tmergedGeometry.morphAttributes[ name ] = [];\n\n\t\tfor ( let i = 0; i < numMorphTargets; ++ i ) {\n\n\t\t\tconst morphAttributesToMerge = [];\n\n\t\t\tfor ( let j = 0; j < morphAttributes[ name ].length; ++ j ) {\n\n\t\t\t\tmorphAttributesToMerge.push( morphAttributes[ name ][ j ][ i ] );\n\n\t\t\t}\n\n\t\t\tconst mergedMorphAttribute = mergeAttributes( morphAttributesToMerge );\n\n\t\t\tif ( ! mergedMorphAttribute ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the ' + name + ' morphAttribute.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tmergedGeometry.morphAttributes[ name ].push( mergedMorphAttribute );\n\n\t\t}\n\n\t}\n\n\treturn mergedGeometry;\n\n}\n\n/**\n * @param {Array<BufferAttribute>} attributes\n * @return {BufferAttribute}\n */\nfunction mergeAttributes( attributes ) {\n\n\tlet TypedArray;\n\tlet itemSize;\n\tlet normalized;\n\tlet gpuType = - 1;\n\tlet arrayLength = 0;\n\n\tfor ( let i = 0; i < attributes.length; ++ i ) {\n\n\t\tconst attribute = attributes[ i ];\n\n\t\tif ( TypedArray === undefined ) TypedArray = attribute.array.constructor;\n\t\tif ( TypedArray !== attribute.array.constructor ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tif ( itemSize === undefined ) itemSize = attribute.itemSize;\n\t\tif ( itemSize !== attribute.itemSize ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tif ( normalized === undefined ) normalized = attribute.normalized;\n\t\tif ( normalized !== attribute.normalized ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tif ( gpuType === - 1 ) gpuType = attribute.gpuType;\n\t\tif ( gpuType !== attribute.gpuType ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.gpuType must be consistent across matching attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tarrayLength += attribute.count * itemSize;\n\n\t}\n\n\tconst array = new TypedArray( arrayLength );\n\tconst result = new BufferAttribute( array, itemSize, normalized );\n\tlet offset = 0;\n\n\tfor ( let i = 0; i < attributes.length; ++ i ) {\n\n\t\tconst attribute = attributes[ i ];\n\t\tif ( attribute.isInterleavedBufferAttribute ) {\n\n\t\t\tconst tupleOffset = offset / itemSize;\n\t\t\tfor ( let j = 0, l = attribute.count; j < l; j ++ ) {\n\n\t\t\t\tfor ( let c = 0; c < itemSize; c ++ ) {\n\n\t\t\t\t\tconst value = attribute.getComponent( j, c );\n\t\t\t\t\tresult.setComponent( j + tupleOffset, c, value );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tarray.set( attribute.array, offset );\n\n\t\t}\n\n\t\toffset += attribute.count * itemSize;\n\n\t}\n\n\tif ( gpuType !== undefined ) {\n\n\t\tresult.gpuType = gpuType;\n\n\t}\n\n\treturn result;\n\n}\n\n/**\n * @param {BufferAttribute}\n * @return {BufferAttribute}\n */\nexport function deepCloneAttribute( attribute ) {\n\n\tif ( attribute.isInstancedInterleavedBufferAttribute || attribute.isInterleavedBufferAttribute ) {\n\n\t\treturn deinterleaveAttribute( attribute );\n\n\t}\n\n\tif ( attribute.isInstancedBufferAttribute ) {\n\n\t\treturn new InstancedBufferAttribute().copy( attribute );\n\n\t}\n\n\treturn new BufferAttribute().copy( attribute );\n\n}\n\n/**\n * @param {Array<BufferAttribute>} attributes\n * @return {Array<InterleavedBufferAttribute>}\n */\nfunction interleaveAttributes( attributes ) {\n\n\t// Interleaves the provided attributes into an InterleavedBuffer and returns\n\t// a set of InterleavedBufferAttributes for each attribute\n\tlet TypedArray;\n\tlet arrayLength = 0;\n\tlet stride = 0;\n\n\t// calculate the length and type of the interleavedBuffer\n\tfor ( let i = 0, l = attributes.length; i < l; ++ i ) {\n\n\t\tconst attribute = attributes[ i ];\n\n\t\tif ( TypedArray === undefined ) TypedArray = attribute.array.constructor;\n\t\tif ( TypedArray !== attribute.array.constructor ) {\n\n\t\t\tconsole.error( 'AttributeBuffers of different types cannot be interleaved' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tarrayLength += attribute.array.length;\n\t\tstride += attribute.itemSize;\n\n\t}\n\n\t// Create the set of buffer attributes\n\tconst interleavedBuffer = new InterleavedBuffer( new TypedArray( arrayLength ), stride );\n\tlet offset = 0;\n\tconst res = [];\n\tconst getters = [ 'getX', 'getY', 'getZ', 'getW' ];\n\tconst setters = [ 'setX', 'setY', 'setZ', 'setW' ];\n\n\tfor ( let j = 0, l = attributes.length; j < l; j ++ ) {\n\n\t\tconst attribute = attributes[ j ];\n\t\tconst itemSize = attribute.itemSize;\n\t\tconst count = attribute.count;\n\t\tconst iba = new InterleavedBufferAttribute( interleavedBuffer, itemSize, offset, attribute.normalized );\n\t\tres.push( iba );\n\n\t\toffset += itemSize;\n\n\t\t// Move the data for each attribute into the new interleavedBuffer\n\t\t// at the appropriate offset\n\t\tfor ( let c = 0; c < count; c ++ ) {\n\n\t\t\tfor ( let k = 0; k < itemSize; k ++ ) {\n\n\t\t\t\tiba[ setters[ k ] ]( c, attribute[ getters[ k ] ]( c ) );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn res;\n\n}\n\n// returns a new, non-interleaved version of the provided attribute\nexport function deinterleaveAttribute( attribute ) {\n\n\tconst cons = attribute.data.array.constructor;\n\tconst count = attribute.count;\n\tconst itemSize = attribute.itemSize;\n\tconst normalized = attribute.normalized;\n\n\tconst array = new cons( count * itemSize );\n\tlet newAttribute;\n\tif ( attribute.isInstancedInterleavedBufferAttribute ) {\n\n\t\tnewAttribute = new InstancedBufferAttribute( array, itemSize, normalized, attribute.meshPerAttribute );\n\n\t} else {\n\n\t\tnewAttribute = new BufferAttribute( array, itemSize, normalized );\n\n\t}\n\n\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\tnewAttribute.setX( i, attribute.getX( i ) );\n\n\t\tif ( itemSize >= 2 ) {\n\n\t\t\tnewAttribute.setY( i, attribute.getY( i ) );\n\n\t\t}\n\n\t\tif ( itemSize >= 3 ) {\n\n\t\t\tnewAttribute.setZ( i, attribute.getZ( i ) );\n\n\t\t}\n\n\t\tif ( itemSize >= 4 ) {\n\n\t\t\tnewAttribute.setW( i, attribute.getW( i ) );\n\n\t\t}\n\n\t}\n\n\treturn newAttribute;\n\n}\n\n// deinterleaves all attributes on the geometry\nexport function deinterleaveGeometry( geometry ) {\n\n\tconst attributes = geometry.attributes;\n\tconst morphTargets = geometry.morphTargets;\n\tconst attrMap = new Map();\n\n\tfor ( const key in attributes ) {\n\n\t\tconst attr = attributes[ key ];\n\t\tif ( attr.isInterleavedBufferAttribute ) {\n\n\t\t\tif ( ! attrMap.has( attr ) ) {\n\n\t\t\t\tattrMap.set( attr, deinterleaveAttribute( attr ) );\n\n\t\t\t}\n\n\t\t\tattributes[ key ] = attrMap.get( attr );\n\n\t\t}\n\n\t}\n\n\tfor ( const key in morphTargets ) {\n\n\t\tconst attr = morphTargets[ key ];\n\t\tif ( attr.isInterleavedBufferAttribute ) {\n\n\t\t\tif ( ! attrMap.has( attr ) ) {\n\n\t\t\t\tattrMap.set( attr, deinterleaveAttribute( attr ) );\n\n\t\t\t}\n\n\t\t\tmorphTargets[ key ] = attrMap.get( attr );\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @return {number}\n */\nfunction estimateBytesUsed( geometry ) {\n\n\t// Return the estimated memory used by this geometry in bytes\n\t// Calculate using itemSize, count, and BYTES_PER_ELEMENT to account\n\t// for InterleavedBufferAttributes.\n\tlet mem = 0;\n\tfor ( const name in geometry.attributes ) {\n\n\t\tconst attr = geometry.getAttribute( name );\n\t\tmem += attr.count * attr.itemSize * attr.array.BYTES_PER_ELEMENT;\n\n\t}\n\n\tconst indices = geometry.getIndex();\n\tmem += indices ? indices.count * indices.itemSize * indices.array.BYTES_PER_ELEMENT : 0;\n\treturn mem;\n\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @param {number} tolerance\n * @return {BufferGeometry}\n */\nfunction mergeVertices( geometry, tolerance = 1e-4 ) {\n\n\ttolerance = Math.max( tolerance, Number.EPSILON );\n\n\t// Generate an index buffer if the geometry doesn't have one, or optimize it\n\t// if it's already available.\n\tconst hashToIndex = {};\n\tconst indices = geometry.getIndex();\n\tconst positions = geometry.getAttribute( 'position' );\n\tconst vertexCount = indices ? indices.count : positions.count;\n\n\t// next value for triangle indices\n\tlet nextIndex = 0;\n\n\t// attributes and new attribute arrays\n\tconst attributeNames = Object.keys( geometry.attributes );\n\tconst tmpAttributes = {};\n\tconst tmpMorphAttributes = {};\n\tconst newIndices = [];\n\tconst getters = [ 'getX', 'getY', 'getZ', 'getW' ];\n\tconst setters = [ 'setX', 'setY', 'setZ', 'setW' ];\n\n\t// Initialize the arrays, allocating space conservatively. Extra\n\t// space will be trimmed in the last step.\n\tfor ( let i = 0, l = attributeNames.length; i < l; i ++ ) {\n\n\t\tconst name = attributeNames[ i ];\n\t\tconst attr = geometry.attributes[ name ];\n\n\t\ttmpAttributes[ name ] = new attr.constructor(\n\t\t\tnew attr.array.constructor( attr.count * attr.itemSize ),\n\t\t\tattr.itemSize,\n\t\t\tattr.normalized\n\t\t);\n\n\t\tconst morphAttributes = geometry.morphAttributes[ name ];\n\t\tif ( morphAttributes ) {\n\n\t\t\tif ( ! tmpMorphAttributes[ name ] ) tmpMorphAttributes[ name ] = [];\n\t\t\tmorphAttributes.forEach( ( morphAttr, i ) => {\n\n\t\t\t\tconst array = new morphAttr.array.constructor( morphAttr.count * morphAttr.itemSize );\n\t\t\t\ttmpMorphAttributes[ name ][ i ] = new morphAttr.constructor( array, morphAttr.itemSize, morphAttr.normalized );\n\n\t\t\t} );\n\n\t\t}\n\n\t}\n\n\t// convert the error tolerance to an amount of decimal places to truncate to\n\tconst halfTolerance = tolerance * 0.5;\n\tconst exponent = Math.log10( 1 / tolerance );\n\tconst hashMultiplier = Math.pow( 10, exponent );\n\tconst hashAdditive = halfTolerance * hashMultiplier;\n\tfor ( let i = 0; i < vertexCount; i ++ ) {\n\n\t\tconst index = indices ? indices.getX( i ) : i;\n\n\t\t// Generate a hash for the vertex attributes at the current index 'i'\n\t\tlet hash = '';\n\t\tfor ( let j = 0, l = attributeNames.length; j < l; j ++ ) {\n\n\t\t\tconst name = attributeNames[ j ];\n\t\t\tconst attribute = geometry.getAttribute( name );\n\t\t\tconst itemSize = attribute.itemSize;\n\n\t\t\tfor ( let k = 0; k < itemSize; k ++ ) {\n\n\t\t\t\t// double tilde truncates the decimal value\n\t\t\t\thash += `${ ~ ~ ( attribute[ getters[ k ] ]( index ) * hashMultiplier + hashAdditive ) },`;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Add another reference to the vertex if it's already\n\t\t// used by another index\n\t\tif ( hash in hashToIndex ) {\n\n\t\t\tnewIndices.push( hashToIndex[ hash ] );\n\n\t\t} else {\n\n\t\t\t// copy data to the new index in the temporary attributes\n\t\t\tfor ( let j = 0, l = attributeNames.length; j < l; j ++ ) {\n\n\t\t\t\tconst name = attributeNames[ j ];\n\t\t\t\tconst attribute = geometry.getAttribute( name );\n\t\t\t\tconst morphAttributes = geometry.morphAttributes[ name ];\n\t\t\t\tconst itemSize = attribute.itemSize;\n\t\t\t\tconst newArray = tmpAttributes[ name ];\n\t\t\t\tconst newMorphArrays = tmpMorphAttributes[ name ];\n\n\t\t\t\tfor ( let k = 0; k < itemSize; k ++ ) {\n\n\t\t\t\t\tconst getterFunc = getters[ k ];\n\t\t\t\t\tconst setterFunc = setters[ k ];\n\t\t\t\t\tnewArray[ setterFunc ]( nextIndex, attribute[ getterFunc ]( index ) );\n\n\t\t\t\t\tif ( morphAttributes ) {\n\n\t\t\t\t\t\tfor ( let m = 0, ml = morphAttributes.length; m < ml; m ++ ) {\n\n\t\t\t\t\t\t\tnewMorphArrays[ m ][ setterFunc ]( nextIndex, morphAttributes[ m ][ getterFunc ]( index ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\thashToIndex[ hash ] = nextIndex;\n\t\t\tnewIndices.push( nextIndex );\n\t\t\tnextIndex ++;\n\n\t\t}\n\n\t}\n\n\t// generate result BufferGeometry\n\tconst result = geometry.clone();\n\tfor ( const name in geometry.attributes ) {\n\n\t\tconst tmpAttribute = tmpAttributes[ name ];\n\n\t\tresult.setAttribute( name, new tmpAttribute.constructor(\n\t\t\ttmpAttribute.array.slice( 0, nextIndex * tmpAttribute.itemSize ),\n\t\t\ttmpAttribute.itemSize,\n\t\t\ttmpAttribute.normalized,\n\t\t) );\n\n\t\tif ( ! ( name in tmpMorphAttributes ) ) continue;\n\n\t\tfor ( let j = 0; j < tmpMorphAttributes[ name ].length; j ++ ) {\n\n\t\t\tconst tmpMorphAttribute = tmpMorphAttributes[ name ][ j ];\n\n\t\t\tresult.morphAttributes[ name ][ j ] = new tmpMorphAttribute.constructor(\n\t\t\t\ttmpMorphAttribute.array.slice( 0, nextIndex * tmpMorphAttribute.itemSize ),\n\t\t\t\ttmpMorphAttribute.itemSize,\n\t\t\t\ttmpMorphAttribute.normalized,\n\t\t\t);\n\n\t\t}\n\n\t}\n\n\t// indices\n\n\tresult.setIndex( newIndices );\n\n\treturn result;\n\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @param {number} drawMode\n * @return {BufferGeometry}\n */\nfunction toTrianglesDrawMode( geometry, drawMode ) {\n\n\tif ( drawMode === TrianglesDrawMode ) {\n\n\t\tconsole.warn( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.' );\n\t\treturn geometry;\n\n\t}\n\n\tif ( drawMode === TriangleFanDrawMode || drawMode === TriangleStripDrawMode ) {\n\n\t\tlet index = geometry.getIndex();\n\n\t\t// generate index if not present\n\n\t\tif ( index === null ) {\n\n\t\t\tconst indices = [];\n\n\t\t\tconst position = geometry.getAttribute( 'position' );\n\n\t\t\tif ( position !== undefined ) {\n\n\t\t\t\tfor ( let i = 0; i < position.count; i ++ ) {\n\n\t\t\t\t\tindices.push( i );\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.setIndex( indices );\n\t\t\t\tindex = geometry.getIndex();\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.' );\n\t\t\t\treturn geometry;\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tconst numberOfTriangles = index.count - 2;\n\t\tconst newIndices = [];\n\n\t\tif ( drawMode === TriangleFanDrawMode ) {\n\n\t\t\t// gl.TRIANGLE_FAN\n\n\t\t\tfor ( let i = 1; i <= numberOfTriangles; i ++ ) {\n\n\t\t\t\tnewIndices.push( index.getX( 0 ) );\n\t\t\t\tnewIndices.push( index.getX( i ) );\n\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// gl.TRIANGLE_STRIP\n\n\t\t\tfor ( let i = 0; i < numberOfTriangles; i ++ ) {\n\n\t\t\t\tif ( i % 2 === 0 ) {\n\n\t\t\t\t\tnewIndices.push( index.getX( i ) );\n\t\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\t\t\t\t\tnewIndices.push( index.getX( i + 2 ) );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tnewIndices.push( index.getX( i + 2 ) );\n\t\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\t\t\t\t\tnewIndices.push( index.getX( i ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( ( newIndices.length / 3 ) !== numberOfTriangles ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.' );\n\n\t\t}\n\n\t\t// build final geometry\n\n\t\tconst newGeometry = geometry.clone();\n\t\tnewGeometry.setIndex( newIndices );\n\t\tnewGeometry.clearGroups();\n\n\t\treturn newGeometry;\n\n\t} else {\n\n\t\tconsole.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:', drawMode );\n\t\treturn geometry;\n\n\t}\n\n}\n\n/**\n * Calculates the morphed attributes of a morphed/skinned BufferGeometry.\n * Helpful for Raytracing or Decals.\n * @param {Mesh | Line | Points} object An instance of Mesh, Line or Points.\n * @return {Object} An Object with original position/normal attributes and morphed ones.\n */\nfunction computeMorphedAttributes( object ) {\n\n\tconst _vA = new Vector3();\n\tconst _vB = new Vector3();\n\tconst _vC = new Vector3();\n\n\tconst _tempA = new Vector3();\n\tconst _tempB = new Vector3();\n\tconst _tempC = new Vector3();\n\n\tconst _morphA = new Vector3();\n\tconst _morphB = new Vector3();\n\tconst _morphC = new Vector3();\n\n\tfunction _calculateMorphedAttributeData(\n\t\tobject,\n\t\tattribute,\n\t\tmorphAttribute,\n\t\tmorphTargetsRelative,\n\t\ta,\n\t\tb,\n\t\tc,\n\t\tmodifiedAttributeArray\n\t) {\n\n\t\t_vA.fromBufferAttribute( attribute, a );\n\t\t_vB.fromBufferAttribute( attribute, b );\n\t\t_vC.fromBufferAttribute( attribute, c );\n\n\t\tconst morphInfluences = object.morphTargetInfluences;\n\n\t\tif ( morphAttribute && morphInfluences ) {\n\n\t\t\t_morphA.set( 0, 0, 0 );\n\t\t\t_morphB.set( 0, 0, 0 );\n\t\t\t_morphC.set( 0, 0, 0 );\n\n\t\t\tfor ( let i = 0, il = morphAttribute.length; i < il; i ++ ) {\n\n\t\t\t\tconst influence = morphInfluences[ i ];\n\t\t\t\tconst morph = morphAttribute[ i ];\n\n\t\t\t\tif ( influence === 0 ) continue;\n\n\t\t\t\t_tempA.fromBufferAttribute( morph, a );\n\t\t\t\t_tempB.fromBufferAttribute( morph, b );\n\t\t\t\t_tempC.fromBufferAttribute( morph, c );\n\n\t\t\t\tif ( morphTargetsRelative ) {\n\n\t\t\t\t\t_morphA.addScaledVector( _tempA, influence );\n\t\t\t\t\t_morphB.addScaledVector( _tempB, influence );\n\t\t\t\t\t_morphC.addScaledVector( _tempC, influence );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t_morphA.addScaledVector( _tempA.sub( _vA ), influence );\n\t\t\t\t\t_morphB.addScaledVector( _tempB.sub( _vB ), influence );\n\t\t\t\t\t_morphC.addScaledVector( _tempC.sub( _vC ), influence );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t_vA.add( _morphA );\n\t\t\t_vB.add( _morphB );\n\t\t\t_vC.add( _morphC );\n\n\t\t}\n\n\t\tif ( object.isSkinnedMesh ) {\n\n\t\t\tobject.applyBoneTransform( a, _vA );\n\t\t\tobject.applyBoneTransform( b, _vB );\n\t\t\tobject.applyBoneTransform( c, _vC );\n\n\t\t}\n\n\t\tmodifiedAttributeArray[ a * 3 + 0 ] = _vA.x;\n\t\tmodifiedAttributeArray[ a * 3 + 1 ] = _vA.y;\n\t\tmodifiedAttributeArray[ a * 3 + 2 ] = _vA.z;\n\t\tmodifiedAttributeArray[ b * 3 + 0 ] = _vB.x;\n\t\tmodifiedAttributeArray[ b * 3 + 1 ] = _vB.y;\n\t\tmodifiedAttributeArray[ b * 3 + 2 ] = _vB.z;\n\t\tmodifiedAttributeArray[ c * 3 + 0 ] = _vC.x;\n\t\tmodifiedAttributeArray[ c * 3 + 1 ] = _vC.y;\n\t\tmodifiedAttributeArray[ c * 3 + 2 ] = _vC.z;\n\n\t}\n\n\tconst geometry = object.geometry;\n\tconst material = object.material;\n\n\tlet a, b, c;\n\tconst index = geometry.index;\n\tconst positionAttribute = geometry.attributes.position;\n\tconst morphPosition = geometry.morphAttributes.position;\n\tconst morphTargetsRelative = geometry.morphTargetsRelative;\n\tconst normalAttribute = geometry.attributes.normal;\n\tconst morphNormal = geometry.morphAttributes.position;\n\n\tconst groups = geometry.groups;\n\tconst drawRange = geometry.drawRange;\n\tlet i, j, il, jl;\n\tlet group;\n\tlet start, end;\n\n\tconst modifiedPosition = new Float32Array( positionAttribute.count * positionAttribute.itemSize );\n\tconst modifiedNormal = new Float32Array( normalAttribute.count * normalAttribute.itemSize );\n\n\tif ( index !== null ) {\n\n\t\t// indexed buffer geometry\n\n\t\tif ( Array.isArray( material ) ) {\n\n\t\t\tfor ( i = 0, il = groups.length; i < il; i ++ ) {\n\n\t\t\t\tgroup = groups[ i ];\n\n\t\t\t\tstart = Math.max( group.start, drawRange.start );\n\t\t\t\tend = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );\n\n\t\t\t\tfor ( j = start, jl = end; j < jl; j += 3 ) {\n\n\t\t\t\t\ta = index.getX( j );\n\t\t\t\t\tb = index.getX( j + 1 );\n\t\t\t\t\tc = index.getX( j + 2 );\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tpositionAttribute,\n\t\t\t\t\t\tmorphPosition,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedPosition\n\t\t\t\t\t);\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tnormalAttribute,\n\t\t\t\t\t\tmorphNormal,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedNormal\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tstart = Math.max( 0, drawRange.start );\n\t\t\tend = Math.min( index.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\tfor ( i = start, il = end; i < il; i += 3 ) {\n\n\t\t\t\ta = index.getX( i );\n\t\t\t\tb = index.getX( i + 1 );\n\t\t\t\tc = index.getX( i + 2 );\n\n\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\tobject,\n\t\t\t\t\tpositionAttribute,\n\t\t\t\t\tmorphPosition,\n\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\ta, b, c,\n\t\t\t\t\tmodifiedPosition\n\t\t\t\t);\n\n\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\tobject,\n\t\t\t\t\tnormalAttribute,\n\t\t\t\t\tmorphNormal,\n\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\ta, b, c,\n\t\t\t\t\tmodifiedNormal\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t} else {\n\n\t\t// non-indexed buffer geometry\n\n\t\tif ( Array.isArray( material ) ) {\n\n\t\t\tfor ( i = 0, il = groups.length; i < il; i ++ ) {\n\n\t\t\t\tgroup = groups[ i ];\n\n\t\t\t\tstart = Math.max( group.start, drawRange.start );\n\t\t\t\tend = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );\n\n\t\t\t\tfor ( j = start, jl = end; j < jl; j += 3 ) {\n\n\t\t\t\t\ta = j;\n\t\t\t\t\tb = j + 1;\n\t\t\t\t\tc = j + 2;\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tpositionAttribute,\n\t\t\t\t\t\tmorphPosition,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedPosition\n\t\t\t\t\t);\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tnormalAttribute,\n\t\t\t\t\t\tmorphNormal,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedNormal\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tstart = Math.max( 0, drawRange.start );\n\t\t\tend = Math.min( positionAttribute.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\tfor ( i = start, il = end; i < il; i += 3 ) {\n\n\t\t\t\ta = i;\n\t\t\t\tb = i + 1;\n\t\t\t\tc = i + 2;\n\n\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\tobject,\n\t\t\t\t\tpositionAttribute,\n\t\t\t\t\tmorphPosition,\n\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\ta, b, c,\n\t\t\t\t\tmodifiedPosition\n\t\t\t\t);\n\n\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\tobject,\n\t\t\t\t\tnormalAttribute,\n\t\t\t\t\tmorphNormal,\n\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\ta, b, c,\n\t\t\t\t\tmodifiedNormal\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tconst morphedPositionAttribute = new Float32BufferAttribute( modifiedPosition, 3 );\n\tconst morphedNormalAttribute = new Float32BufferAttribute( modifiedNormal, 3 );\n\n\treturn {\n\n\t\tpositionAttribute: positionAttribute,\n\t\tnormalAttribute: normalAttribute,\n\t\tmorphedPositionAttribute: morphedPositionAttribute,\n\t\tmorphedNormalAttribute: morphedNormalAttribute\n\n\t};\n\n}\n\nfunction mergeGroups( geometry ) {\n\n\tif ( geometry.groups.length === 0 ) {\n\n\t\tconsole.warn( 'THREE.BufferGeometryUtils.mergeGroups(): No groups are defined. Nothing to merge.' );\n\t\treturn geometry;\n\n\t}\n\n\tlet groups = geometry.groups;\n\n\t// sort groups by material index\n\n\tgroups = groups.sort( ( a, b ) => {\n\n\t\tif ( a.materialIndex !== b.materialIndex ) return a.materialIndex - b.materialIndex;\n\n\t\treturn a.start - b.start;\n\n\t} );\n\n\t// create index for non-indexed geometries\n\n\tif ( geometry.getIndex() === null ) {\n\n\t\tconst positionAttribute = geometry.getAttribute( 'position' );\n\t\tconst indices = [];\n\n\t\tfor ( let i = 0; i < positionAttribute.count; i += 3 ) {\n\n\t\t\tindices.push( i, i + 1, i + 2 );\n\n\t\t}\n\n\t\tgeometry.setIndex( indices );\n\n\t}\n\n\t// sort index\n\n\tconst index = geometry.getIndex();\n\n\tconst newIndices = [];\n\n\tfor ( let i = 0; i < groups.length; i ++ ) {\n\n\t\tconst group = groups[ i ];\n\n\t\tconst groupStart = group.start;\n\t\tconst groupLength = groupStart + group.count;\n\n\t\tfor ( let j = groupStart; j < groupLength; j ++ ) {\n\n\t\t\tnewIndices.push( index.getX( j ) );\n\n\t\t}\n\n\t}\n\n\tgeometry.dispose(); // Required to force buffer recreation\n\tgeometry.setIndex( newIndices );\n\n\t// update groups indices\n\n\tlet start = 0;\n\n\tfor ( let i = 0; i < groups.length; i ++ ) {\n\n\t\tconst group = groups[ i ];\n\n\t\tgroup.start = start;\n\t\tstart += group.count;\n\n\t}\n\n\t// merge groups\n\n\tlet currentGroup = groups[ 0 ];\n\n\tgeometry.groups = [ currentGroup ];\n\n\tfor ( let i = 1; i < groups.length; i ++ ) {\n\n\t\tconst group = groups[ i ];\n\n\t\tif ( currentGroup.materialIndex === group.materialIndex ) {\n\n\t\t\tcurrentGroup.count += group.count;\n\n\t\t} else {\n\n\t\t\tcurrentGroup = group;\n\t\t\tgeometry.groups.push( currentGroup );\n\n\t\t}\n\n\t}\n\n\treturn geometry;\n\n}\n\n\n/**\n * Modifies the supplied geometry if it is non-indexed, otherwise creates a new,\n * non-indexed geometry. Returns the geometry with smooth normals everywhere except\n * faces that meet at an angle greater than the crease angle.\n *\n * @param {BufferGeometry} geometry\n * @param {number} [creaseAngle]\n * @return {BufferGeometry}\n */\nfunction toCreasedNormals( geometry, creaseAngle = Math.PI / 3 /* 60 degrees */ ) {\n\n\tconst creaseDot = Math.cos( creaseAngle );\n\tconst hashMultiplier = ( 1 + 1e-10 ) * 1e2;\n\n\t// reusable vectors\n\tconst verts = [ new Vector3(), new Vector3(), new Vector3() ];\n\tconst tempVec1 = new Vector3();\n\tconst tempVec2 = new Vector3();\n\tconst tempNorm = new Vector3();\n\tconst tempNorm2 = new Vector3();\n\n\t// hashes a vector\n\tfunction hashVertex( v ) {\n\n\t\tconst x = ~ ~ ( v.x * hashMultiplier );\n\t\tconst y = ~ ~ ( v.y * hashMultiplier );\n\t\tconst z = ~ ~ ( v.z * hashMultiplier );\n\t\treturn `${x},${y},${z}`;\n\n\t}\n\n\t// BufferGeometry.toNonIndexed() warns if the geometry is non-indexed\n\t// and returns the original geometry\n\tconst resultGeometry = geometry.index ? geometry.toNonIndexed() : geometry;\n\tconst posAttr = resultGeometry.attributes.position;\n\tconst vertexMap = {};\n\n\t// find all the normals shared by commonly located vertices\n\tfor ( let i = 0, l = posAttr.count / 3; i < l; i ++ ) {\n\n\t\tconst i3 = 3 * i;\n\t\tconst a = verts[ 0 ].fromBufferAttribute( posAttr, i3 + 0 );\n\t\tconst b = verts[ 1 ].fromBufferAttribute( posAttr, i3 + 1 );\n\t\tconst c = verts[ 2 ].fromBufferAttribute( posAttr, i3 + 2 );\n\n\t\ttempVec1.subVectors( c, b );\n\t\ttempVec2.subVectors( a, b );\n\n\t\t// add the normal to the map for all vertices\n\t\tconst normal = new Vector3().crossVectors( tempVec1, tempVec2 ).normalize();\n\t\tfor ( let n = 0; n < 3; n ++ ) {\n\n\t\t\tconst vert = verts[ n ];\n\t\t\tconst hash = hashVertex( vert );\n\t\t\tif ( ! ( hash in vertexMap ) ) {\n\n\t\t\t\tvertexMap[ hash ] = [];\n\n\t\t\t}\n\n\t\t\tvertexMap[ hash ].push( normal );\n\n\t\t}\n\n\t}\n\n\t// average normals from all vertices that share a common location if they are within the\n\t// provided crease threshold\n\tconst normalArray = new Float32Array( posAttr.count * 3 );\n\tconst normAttr = new BufferAttribute( normalArray, 3, false );\n\tfor ( let i = 0, l = posAttr.count / 3; i < l; i ++ ) {\n\n\t\t// get the face normal for this vertex\n\t\tconst i3 = 3 * i;\n\t\tconst a = verts[ 0 ].fromBufferAttribute( posAttr, i3 + 0 );\n\t\tconst b = verts[ 1 ].fromBufferAttribute( posAttr, i3 + 1 );\n\t\tconst c = verts[ 2 ].fromBufferAttribute( posAttr, i3 + 2 );\n\n\t\ttempVec1.subVectors( c, b );\n\t\ttempVec2.subVectors( a, b );\n\n\t\ttempNorm.crossVectors( tempVec1, tempVec2 ).normalize();\n\n\t\t// average all normals that meet the threshold and set the normal value\n\t\tfor ( let n = 0; n < 3; n ++ ) {\n\n\t\t\tconst vert = verts[ n ];\n\t\t\tconst hash = hashVertex( vert );\n\t\t\tconst otherNormals = vertexMap[ hash ];\n\t\t\ttempNorm2.set( 0, 0, 0 );\n\n\t\t\tfor ( let k = 0, lk = otherNormals.length; k < lk; k ++ ) {\n\n\t\t\t\tconst otherNorm = otherNormals[ k ];\n\t\t\t\tif ( tempNorm.dot( otherNorm ) > creaseDot ) {\n\n\t\t\t\t\ttempNorm2.add( otherNorm );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\ttempNorm2.normalize();\n\t\t\tnormAttr.setXYZ( i3 + n, tempNorm2.x, tempNorm2.y, tempNorm2.z );\n\n\t\t}\n\n\t}\n\n\tresultGeometry.setAttribute( 'normal', normAttr );\n\treturn resultGeometry;\n\n}\n\nexport {\n\tcomputeMikkTSpaceTangents,\n\tmergeGeometries,\n\tmergeAttributes,\n\tinterleaveAttributes,\n\testimateBytesUsed,\n\tmergeVertices,\n\ttoTrianglesDrawMode,\n\tcomputeMorphedAttributes,\n\tmergeGroups,\n\ttoCreasedNormals\n};\n","import {\n\tAnimationClip,\n\tBone,\n\tBox3,\n\tBufferAttribute,\n\tBufferGeometry,\n\tClampToEdgeWrapping,\n\tColor,\n\tColorManagement,\n\tDirectionalLight,\n\tDoubleSide,\n\tFileLoader,\n\tFrontSide,\n\tGroup,\n\tImageBitmapLoader,\n\tInstancedMesh,\n\tInterleavedBuffer,\n\tInterleavedBufferAttribute,\n\tInterpolant,\n\tInterpolateDiscrete,\n\tInterpolateLinear,\n\tLine,\n\tLineBasicMaterial,\n\tLineLoop,\n\tLineSegments,\n\tLinearFilter,\n\tLinearMipmapLinearFilter,\n\tLinearMipmapNearestFilter,\n\tLinearSRGBColorSpace,\n\tLoader,\n\tLoaderUtils,\n\tMaterial,\n\tMathUtils,\n\tMatrix4,\n\tMesh,\n\tMeshBasicMaterial,\n\tMeshPhysicalMaterial,\n\tMeshStandardMaterial,\n\tMirroredRepeatWrapping,\n\tNearestFilter,\n\tNearestMipmapLinearFilter,\n\tNearestMipmapNearestFilter,\n\tNumberKeyframeTrack,\n\tObject3D,\n\tOrthographicCamera,\n\tPerspectiveCamera,\n\tPointLight,\n\tPoints,\n\tPointsMaterial,\n\tPropertyBinding,\n\tQuaternion,\n\tQuaternionKeyframeTrack,\n\tRepeatWrapping,\n\tSkeleton,\n\tSkinnedMesh,\n\tSphere,\n\tSpotLight,\n\tTexture,\n\tTextureLoader,\n\tTriangleFanDrawMode,\n\tTriangleStripDrawMode,\n\tVector2,\n\tVector3,\n\tVectorKeyframeTrack,\n\tSRGBColorSpace,\n\tInstancedBufferAttribute\n} from 'three';\nimport { toTrianglesDrawMode } from '../utils/BufferGeometryUtils.js';\n\nclass GLTFLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t\tthis.dracoLoader = null;\n\t\tthis.ktx2Loader = null;\n\t\tthis.meshoptDecoder = null;\n\n\t\tthis.pluginCallbacks = [];\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMaterialsClearcoatExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMaterialsDispersionExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFTextureBasisUExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFTextureWebPExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFTextureAVIFExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMaterialsSheenExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMaterialsTransmissionExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMaterialsVolumeExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMaterialsIorExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMaterialsEmissiveStrengthExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMaterialsSpecularExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMaterialsIridescenceExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMaterialsAnisotropyExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMaterialsBumpExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFLightsExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMeshoptCompression( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMeshGpuInstancing( parser );\n\n\t\t} );\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tlet resourcePath;\n\n\t\tif ( this.resourcePath !== '' ) {\n\n\t\t\tresourcePath = this.resourcePath;\n\n\t\t} else if ( this.path !== '' ) {\n\n\t\t\t// If a base path is set, resources will be relative paths from that plus the relative path of the gltf file\n\t\t\t// Example  path = 'https://my-cnd-server.com/', url = 'assets/models/model.gltf'\n\t\t\t// resourcePath = 'https://my-cnd-server.com/assets/models/'\n\t\t\t// referenced resource 'model.bin' will be loaded from 'https://my-cnd-server.com/assets/models/model.bin'\n\t\t\t// referenced resource '../textures/texture.png' will be loaded from 'https://my-cnd-server.com/assets/textures/texture.png'\n\t\t\tconst relativeUrl = LoaderUtils.extractUrlBase( url );\n\t\t\tresourcePath = LoaderUtils.resolveURL( relativeUrl, this.path );\n\n\t\t} else {\n\n\t\t\tresourcePath = LoaderUtils.extractUrlBase( url );\n\n\t\t}\n\n\t\t// Tells the LoadingManager to track an extra item, which resolves after\n\t\t// the model is fully loaded. This means the count of items loaded will\n\t\t// be incorrect, but ensures manager.onLoad() does not fire early.\n\t\tthis.manager.itemStart( url );\n\n\t\tconst _onError = function ( e ) {\n\n\t\t\tif ( onError ) {\n\n\t\t\t\tonError( e );\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( e );\n\n\t\t\t}\n\n\t\t\tscope.manager.itemError( url );\n\t\t\tscope.manager.itemEnd( url );\n\n\t\t};\n\n\t\tconst loader = new FileLoader( this.manager );\n\n\t\tloader.setPath( this.path );\n\t\tloader.setResponseType( 'arraybuffer' );\n\t\tloader.setRequestHeader( this.requestHeader );\n\t\tloader.setWithCredentials( this.withCredentials );\n\n\t\tloader.load( url, function ( data ) {\n\n\t\t\ttry {\n\n\t\t\t\tscope.parse( data, resourcePath, function ( gltf ) {\n\n\t\t\t\t\tonLoad( gltf );\n\n\t\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t\t}, _onError );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\t_onError( e );\n\n\t\t\t}\n\n\t\t}, onProgress, _onError );\n\n\t}\n\n\tsetDRACOLoader( dracoLoader ) {\n\n\t\tthis.dracoLoader = dracoLoader;\n\t\treturn this;\n\n\t}\n\n\tsetDDSLoader() {\n\n\t\tthrow new Error(\n\n\t\t\t'THREE.GLTFLoader: \"MSFT_texture_dds\" no longer supported. Please update to \"KHR_texture_basisu\".'\n\n\t\t);\n\n\t}\n\n\tsetKTX2Loader( ktx2Loader ) {\n\n\t\tthis.ktx2Loader = ktx2Loader;\n\t\treturn this;\n\n\t}\n\n\tsetMeshoptDecoder( meshoptDecoder ) {\n\n\t\tthis.meshoptDecoder = meshoptDecoder;\n\t\treturn this;\n\n\t}\n\n\tregister( callback ) {\n\n\t\tif ( this.pluginCallbacks.indexOf( callback ) === - 1 ) {\n\n\t\t\tthis.pluginCallbacks.push( callback );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tunregister( callback ) {\n\n\t\tif ( this.pluginCallbacks.indexOf( callback ) !== - 1 ) {\n\n\t\t\tthis.pluginCallbacks.splice( this.pluginCallbacks.indexOf( callback ), 1 );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tparse( data, path, onLoad, onError ) {\n\n\t\tlet json;\n\t\tconst extensions = {};\n\t\tconst plugins = {};\n\t\tconst textDecoder = new TextDecoder();\n\n\t\tif ( typeof data === 'string' ) {\n\n\t\t\tjson = JSON.parse( data );\n\n\t\t} else if ( data instanceof ArrayBuffer ) {\n\n\t\t\tconst magic = textDecoder.decode( new Uint8Array( data, 0, 4 ) );\n\n\t\t\tif ( magic === BINARY_EXTENSION_HEADER_MAGIC ) {\n\n\t\t\t\ttry {\n\n\t\t\t\t\textensions[ EXTENSIONS.KHR_BINARY_GLTF ] = new GLTFBinaryExtension( data );\n\n\t\t\t\t} catch ( error ) {\n\n\t\t\t\t\tif ( onError ) onError( error );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tjson = JSON.parse( extensions[ EXTENSIONS.KHR_BINARY_GLTF ].content );\n\n\t\t\t} else {\n\n\t\t\t\tjson = JSON.parse( textDecoder.decode( data ) );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tjson = data;\n\n\t\t}\n\n\t\tif ( json.asset === undefined || json.asset.version[ 0 ] < 2 ) {\n\n\t\t\tif ( onError ) onError( new Error( 'THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.' ) );\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst parser = new GLTFParser( json, {\n\n\t\t\tpath: path || this.resourcePath || '',\n\t\t\tcrossOrigin: this.crossOrigin,\n\t\t\trequestHeader: this.requestHeader,\n\t\t\tmanager: this.manager,\n\t\t\tktx2Loader: this.ktx2Loader,\n\t\t\tmeshoptDecoder: this.meshoptDecoder\n\n\t\t} );\n\n\t\tparser.fileLoader.setRequestHeader( this.requestHeader );\n\n\t\tfor ( let i = 0; i < this.pluginCallbacks.length; i ++ ) {\n\n\t\t\tconst plugin = this.pluginCallbacks[ i ]( parser );\n\n\t\t\tif ( ! plugin.name ) console.error( 'THREE.GLTFLoader: Invalid plugin found: missing name' );\n\n\t\t\tplugins[ plugin.name ] = plugin;\n\n\t\t\t// Workaround to avoid determining as unknown extension\n\t\t\t// in addUnknownExtensionsToUserData().\n\t\t\t// Remove this workaround if we move all the existing\n\t\t\t// extension handlers to plugin system\n\t\t\textensions[ plugin.name ] = true;\n\n\t\t}\n\n\t\tif ( json.extensionsUsed ) {\n\n\t\t\tfor ( let i = 0; i < json.extensionsUsed.length; ++ i ) {\n\n\t\t\t\tconst extensionName = json.extensionsUsed[ i ];\n\t\t\t\tconst extensionsRequired = json.extensionsRequired || [];\n\n\t\t\t\tswitch ( extensionName ) {\n\n\t\t\t\t\tcase EXTENSIONS.KHR_MATERIALS_UNLIT:\n\t\t\t\t\t\textensions[ extensionName ] = new GLTFMaterialsUnlitExtension();\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:\n\t\t\t\t\t\textensions[ extensionName ] = new GLTFDracoMeshCompressionExtension( json, this.dracoLoader );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase EXTENSIONS.KHR_TEXTURE_TRANSFORM:\n\t\t\t\t\t\textensions[ extensionName ] = new GLTFTextureTransformExtension();\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase EXTENSIONS.KHR_MESH_QUANTIZATION:\n\t\t\t\t\t\textensions[ extensionName ] = new GLTFMeshQuantizationExtension();\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\n\t\t\t\t\t\tif ( extensionsRequired.indexOf( extensionName ) >= 0 && plugins[ extensionName ] === undefined ) {\n\n\t\t\t\t\t\t\tconsole.warn( 'THREE.GLTFLoader: Unknown extension \"' + extensionName + '\".' );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tparser.setExtensions( extensions );\n\t\tparser.setPlugins( plugins );\n\t\tparser.parse( onLoad, onError );\n\n\t}\n\n\tparseAsync( data, path ) {\n\n\t\tconst scope = this;\n\n\t\treturn new Promise( function ( resolve, reject ) {\n\n\t\t\tscope.parse( data, path, resolve, reject );\n\n\t\t} );\n\n\t}\n\n}\n\n/* GLTFREGISTRY */\n\nfunction GLTFRegistry() {\n\n\tlet objects = {};\n\n\treturn\t{\n\n\t\tget: function ( key ) {\n\n\t\t\treturn objects[ key ];\n\n\t\t},\n\n\t\tadd: function ( key, object ) {\n\n\t\t\tobjects[ key ] = object;\n\n\t\t},\n\n\t\tremove: function ( key ) {\n\n\t\t\tdelete objects[ key ];\n\n\t\t},\n\n\t\tremoveAll: function () {\n\n\t\t\tobjects = {};\n\n\t\t}\n\n\t};\n\n}\n\n/*********************************/\n/********** EXTENSIONS ***********/\n/*********************************/\n\nconst EXTENSIONS = {\n\tKHR_BINARY_GLTF: 'KHR_binary_glTF',\n\tKHR_DRACO_MESH_COMPRESSION: 'KHR_draco_mesh_compression',\n\tKHR_LIGHTS_PUNCTUAL: 'KHR_lights_punctual',\n\tKHR_MATERIALS_CLEARCOAT: 'KHR_materials_clearcoat',\n\tKHR_MATERIALS_DISPERSION: 'KHR_materials_dispersion',\n\tKHR_MATERIALS_IOR: 'KHR_materials_ior',\n\tKHR_MATERIALS_SHEEN: 'KHR_materials_sheen',\n\tKHR_MATERIALS_SPECULAR: 'KHR_materials_specular',\n\tKHR_MATERIALS_TRANSMISSION: 'KHR_materials_transmission',\n\tKHR_MATERIALS_IRIDESCENCE: 'KHR_materials_iridescence',\n\tKHR_MATERIALS_ANISOTROPY: 'KHR_materials_anisotropy',\n\tKHR_MATERIALS_UNLIT: 'KHR_materials_unlit',\n\tKHR_MATERIALS_VOLUME: 'KHR_materials_volume',\n\tKHR_TEXTURE_BASISU: 'KHR_texture_basisu',\n\tKHR_TEXTURE_TRANSFORM: 'KHR_texture_transform',\n\tKHR_MESH_QUANTIZATION: 'KHR_mesh_quantization',\n\tKHR_MATERIALS_EMISSIVE_STRENGTH: 'KHR_materials_emissive_strength',\n\tEXT_MATERIALS_BUMP: 'EXT_materials_bump',\n\tEXT_TEXTURE_WEBP: 'EXT_texture_webp',\n\tEXT_TEXTURE_AVIF: 'EXT_texture_avif',\n\tEXT_MESHOPT_COMPRESSION: 'EXT_meshopt_compression',\n\tEXT_MESH_GPU_INSTANCING: 'EXT_mesh_gpu_instancing'\n};\n\n/**\n * Punctual Lights Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual\n */\nclass GLTFLightsExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL;\n\n\t\t// Object3D instance caches\n\t\tthis.cache = { refs: {}, uses: {} };\n\n\t}\n\n\t_markDefs() {\n\n\t\tconst parser = this.parser;\n\t\tconst nodeDefs = this.parser.json.nodes || [];\n\n\t\tfor ( let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex ++ ) {\n\n\t\t\tconst nodeDef = nodeDefs[ nodeIndex ];\n\n\t\t\tif ( nodeDef.extensions\n\t\t\t\t\t&& nodeDef.extensions[ this.name ]\n\t\t\t\t\t&& nodeDef.extensions[ this.name ].light !== undefined ) {\n\n\t\t\t\tparser._addNodeRef( this.cache, nodeDef.extensions[ this.name ].light );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t_loadLight( lightIndex ) {\n\n\t\tconst parser = this.parser;\n\t\tconst cacheKey = 'light:' + lightIndex;\n\t\tlet dependency = parser.cache.get( cacheKey );\n\n\t\tif ( dependency ) return dependency;\n\n\t\tconst json = parser.json;\n\t\tconst extensions = ( json.extensions && json.extensions[ this.name ] ) || {};\n\t\tconst lightDefs = extensions.lights || [];\n\t\tconst lightDef = lightDefs[ lightIndex ];\n\t\tlet lightNode;\n\n\t\tconst color = new Color( 0xffffff );\n\n\t\tif ( lightDef.color !== undefined ) color.setRGB( lightDef.color[ 0 ], lightDef.color[ 1 ], lightDef.color[ 2 ], LinearSRGBColorSpace );\n\n\t\tconst range = lightDef.range !== undefined ? lightDef.range : 0;\n\n\t\tswitch ( lightDef.type ) {\n\n\t\t\tcase 'directional':\n\t\t\t\tlightNode = new DirectionalLight( color );\n\t\t\t\tlightNode.target.position.set( 0, 0, - 1 );\n\t\t\t\tlightNode.add( lightNode.target );\n\t\t\t\tbreak;\n\n\t\t\tcase 'point':\n\t\t\t\tlightNode = new PointLight( color );\n\t\t\t\tlightNode.distance = range;\n\t\t\t\tbreak;\n\n\t\t\tcase 'spot':\n\t\t\t\tlightNode = new SpotLight( color );\n\t\t\t\tlightNode.distance = range;\n\t\t\t\t// Handle spotlight properties.\n\t\t\t\tlightDef.spot = lightDef.spot || {};\n\t\t\t\tlightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== undefined ? lightDef.spot.innerConeAngle : 0;\n\t\t\t\tlightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== undefined ? lightDef.spot.outerConeAngle : Math.PI / 4.0;\n\t\t\t\tlightNode.angle = lightDef.spot.outerConeAngle;\n\t\t\t\tlightNode.penumbra = 1.0 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;\n\t\t\t\tlightNode.target.position.set( 0, 0, - 1 );\n\t\t\t\tlightNode.add( lightNode.target );\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tthrow new Error( 'THREE.GLTFLoader: Unexpected light type: ' + lightDef.type );\n\n\t\t}\n\n\t\t// Some lights (e.g. spot) default to a position other than the origin. Reset the position\n\t\t// here, because node-level parsing will only override position if explicitly specified.\n\t\tlightNode.position.set( 0, 0, 0 );\n\n\t\tlightNode.decay = 2;\n\n\t\tassignExtrasToUserData( lightNode, lightDef );\n\n\t\tif ( lightDef.intensity !== undefined ) lightNode.intensity = lightDef.intensity;\n\n\t\tlightNode.name = parser.createUniqueName( lightDef.name || ( 'light_' + lightIndex ) );\n\n\t\tdependency = Promise.resolve( lightNode );\n\n\t\tparser.cache.add( cacheKey, dependency );\n\n\t\treturn dependency;\n\n\t}\n\n\tgetDependency( type, index ) {\n\n\t\tif ( type !== 'light' ) return;\n\n\t\treturn this._loadLight( index );\n\n\t}\n\n\tcreateNodeAttachment( nodeIndex ) {\n\n\t\tconst self = this;\n\t\tconst parser = this.parser;\n\t\tconst json = parser.json;\n\t\tconst nodeDef = json.nodes[ nodeIndex ];\n\t\tconst lightDef = ( nodeDef.extensions && nodeDef.extensions[ this.name ] ) || {};\n\t\tconst lightIndex = lightDef.light;\n\n\t\tif ( lightIndex === undefined ) return null;\n\n\t\treturn this._loadLight( lightIndex ).then( function ( light ) {\n\n\t\t\treturn parser._getNodeRef( self.cache, lightIndex, light );\n\n\t\t} );\n\n\t}\n\n}\n\n/**\n * Unlit Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit\n */\nclass GLTFMaterialsUnlitExtension {\n\n\tconstructor() {\n\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_UNLIT;\n\n\t}\n\n\tgetMaterialType() {\n\n\t\treturn MeshBasicMaterial;\n\n\t}\n\n\textendParams( materialParams, materialDef, parser ) {\n\n\t\tconst pending = [];\n\n\t\tmaterialParams.color = new Color( 1.0, 1.0, 1.0 );\n\t\tmaterialParams.opacity = 1.0;\n\n\t\tconst metallicRoughness = materialDef.pbrMetallicRoughness;\n\n\t\tif ( metallicRoughness ) {\n\n\t\t\tif ( Array.isArray( metallicRoughness.baseColorFactor ) ) {\n\n\t\t\t\tconst array = metallicRoughness.baseColorFactor;\n\n\t\t\t\tmaterialParams.color.setRGB( array[ 0 ], array[ 1 ], array[ 2 ], LinearSRGBColorSpace );\n\t\t\t\tmaterialParams.opacity = array[ 3 ];\n\n\t\t\t}\n\n\t\t\tif ( metallicRoughness.baseColorTexture !== undefined ) {\n\n\t\t\t\tpending.push( parser.assignTexture( materialParams, 'map', metallicRoughness.baseColorTexture, SRGBColorSpace ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn Promise.all( pending );\n\n\t}\n\n}\n\n/**\n * Materials Emissive Strength Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/blob/5768b3ce0ef32bc39cdf1bef10b948586635ead3/extensions/2.0/Khronos/KHR_materials_emissive_strength/README.md\n */\nclass GLTFMaterialsEmissiveStrengthExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_EMISSIVE_STRENGTH;\n\n\t}\n\n\textendMaterialParams( materialIndex, materialParams ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\n\n\t\t\treturn Promise.resolve();\n\n\t\t}\n\n\t\tconst emissiveStrength = materialDef.extensions[ this.name ].emissiveStrength;\n\n\t\tif ( emissiveStrength !== undefined ) {\n\n\t\t\tmaterialParams.emissiveIntensity = emissiveStrength;\n\n\t\t}\n\n\t\treturn Promise.resolve();\n\n\t}\n\n}\n\n/**\n * Clearcoat Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat\n */\nclass GLTFMaterialsClearcoatExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT;\n\n\t}\n\n\tgetMaterialType( materialIndex ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;\n\n\t\treturn MeshPhysicalMaterial;\n\n\t}\n\n\textendMaterialParams( materialIndex, materialParams ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\n\n\t\t\treturn Promise.resolve();\n\n\t\t}\n\n\t\tconst pending = [];\n\n\t\tconst extension = materialDef.extensions[ this.name ];\n\n\t\tif ( extension.clearcoatFactor !== undefined ) {\n\n\t\t\tmaterialParams.clearcoat = extension.clearcoatFactor;\n\n\t\t}\n\n\t\tif ( extension.clearcoatTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'clearcoatMap', extension.clearcoatTexture ) );\n\n\t\t}\n\n\t\tif ( extension.clearcoatRoughnessFactor !== undefined ) {\n\n\t\t\tmaterialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor;\n\n\t\t}\n\n\t\tif ( extension.clearcoatRoughnessTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'clearcoatRoughnessMap', extension.clearcoatRoughnessTexture ) );\n\n\t\t}\n\n\t\tif ( extension.clearcoatNormalTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'clearcoatNormalMap', extension.clearcoatNormalTexture ) );\n\n\t\t\tif ( extension.clearcoatNormalTexture.scale !== undefined ) {\n\n\t\t\t\tconst scale = extension.clearcoatNormalTexture.scale;\n\n\t\t\t\tmaterialParams.clearcoatNormalScale = new Vector2( scale, scale );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn Promise.all( pending );\n\n\t}\n\n}\n\n/**\n * Materials dispersion Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_dispersion\n */\nclass GLTFMaterialsDispersionExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_DISPERSION;\n\n\t}\n\n\tgetMaterialType( materialIndex ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;\n\n\t\treturn MeshPhysicalMaterial;\n\n\t}\n\n\textendMaterialParams( materialIndex, materialParams ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\n\n\t\t\treturn Promise.resolve();\n\n\t\t}\n\n\t\tconst extension = materialDef.extensions[ this.name ];\n\n\t\tmaterialParams.dispersion = extension.dispersion !== undefined ? extension.dispersion : 0;\n\n\t\treturn Promise.resolve();\n\n\t}\n\n}\n\n/**\n * Iridescence Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_iridescence\n */\nclass GLTFMaterialsIridescenceExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_IRIDESCENCE;\n\n\t}\n\n\tgetMaterialType( materialIndex ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;\n\n\t\treturn MeshPhysicalMaterial;\n\n\t}\n\n\textendMaterialParams( materialIndex, materialParams ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\n\n\t\t\treturn Promise.resolve();\n\n\t\t}\n\n\t\tconst pending = [];\n\n\t\tconst extension = materialDef.extensions[ this.name ];\n\n\t\tif ( extension.iridescenceFactor !== undefined ) {\n\n\t\t\tmaterialParams.iridescence = extension.iridescenceFactor;\n\n\t\t}\n\n\t\tif ( extension.iridescenceTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'iridescenceMap', extension.iridescenceTexture ) );\n\n\t\t}\n\n\t\tif ( extension.iridescenceIor !== undefined ) {\n\n\t\t\tmaterialParams.iridescenceIOR = extension.iridescenceIor;\n\n\t\t}\n\n\t\tif ( materialParams.iridescenceThicknessRange === undefined ) {\n\n\t\t\tmaterialParams.iridescenceThicknessRange = [ 100, 400 ];\n\n\t\t}\n\n\t\tif ( extension.iridescenceThicknessMinimum !== undefined ) {\n\n\t\t\tmaterialParams.iridescenceThicknessRange[ 0 ] = extension.iridescenceThicknessMinimum;\n\n\t\t}\n\n\t\tif ( extension.iridescenceThicknessMaximum !== undefined ) {\n\n\t\t\tmaterialParams.iridescenceThicknessRange[ 1 ] = extension.iridescenceThicknessMaximum;\n\n\t\t}\n\n\t\tif ( extension.iridescenceThicknessTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'iridescenceThicknessMap', extension.iridescenceThicknessTexture ) );\n\n\t\t}\n\n\t\treturn Promise.all( pending );\n\n\t}\n\n}\n\n/**\n * Sheen Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_sheen\n */\nclass GLTFMaterialsSheenExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_SHEEN;\n\n\t}\n\n\tgetMaterialType( materialIndex ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;\n\n\t\treturn MeshPhysicalMaterial;\n\n\t}\n\n\textendMaterialParams( materialIndex, materialParams ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\n\n\t\t\treturn Promise.resolve();\n\n\t\t}\n\n\t\tconst pending = [];\n\n\t\tmaterialParams.sheenColor = new Color( 0, 0, 0 );\n\t\tmaterialParams.sheenRoughness = 0;\n\t\tmaterialParams.sheen = 1;\n\n\t\tconst extension = materialDef.extensions[ this.name ];\n\n\t\tif ( extension.sheenColorFactor !== undefined ) {\n\n\t\t\tconst colorFactor = extension.sheenColorFactor;\n\t\t\tmaterialParams.sheenColor.setRGB( colorFactor[ 0 ], colorFactor[ 1 ], colorFactor[ 2 ], LinearSRGBColorSpace );\n\n\t\t}\n\n\t\tif ( extension.sheenRoughnessFactor !== undefined ) {\n\n\t\t\tmaterialParams.sheenRoughness = extension.sheenRoughnessFactor;\n\n\t\t}\n\n\t\tif ( extension.sheenColorTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'sheenColorMap', extension.sheenColorTexture, SRGBColorSpace ) );\n\n\t\t}\n\n\t\tif ( extension.sheenRoughnessTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'sheenRoughnessMap', extension.sheenRoughnessTexture ) );\n\n\t\t}\n\n\t\treturn Promise.all( pending );\n\n\t}\n\n}\n\n/**\n * Transmission Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_transmission\n * Draft: https://github.com/KhronosGroup/glTF/pull/1698\n */\nclass GLTFMaterialsTransmissionExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION;\n\n\t}\n\n\tgetMaterialType( materialIndex ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;\n\n\t\treturn MeshPhysicalMaterial;\n\n\t}\n\n\textendMaterialParams( materialIndex, materialParams ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\n\n\t\t\treturn Promise.resolve();\n\n\t\t}\n\n\t\tconst pending = [];\n\n\t\tconst extension = materialDef.extensions[ this.name ];\n\n\t\tif ( extension.transmissionFactor !== undefined ) {\n\n\t\t\tmaterialParams.transmission = extension.transmissionFactor;\n\n\t\t}\n\n\t\tif ( extension.transmissionTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'transmissionMap', extension.transmissionTexture ) );\n\n\t\t}\n\n\t\treturn Promise.all( pending );\n\n\t}\n\n}\n\n/**\n * Materials Volume Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_volume\n */\nclass GLTFMaterialsVolumeExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_VOLUME;\n\n\t}\n\n\tgetMaterialType( materialIndex ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;\n\n\t\treturn MeshPhysicalMaterial;\n\n\t}\n\n\textendMaterialParams( materialIndex, materialParams ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\n\n\t\t\treturn Promise.resolve();\n\n\t\t}\n\n\t\tconst pending = [];\n\n\t\tconst extension = materialDef.extensions[ this.name ];\n\n\t\tmaterialParams.thickness = extension.thicknessFactor !== undefined ? extension.thicknessFactor : 0;\n\n\t\tif ( extension.thicknessTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'thicknessMap', extension.thicknessTexture ) );\n\n\t\t}\n\n\t\tmaterialParams.attenuationDistance = extension.attenuationDistance || Infinity;\n\n\t\tconst colorArray = extension.attenuationColor || [ 1, 1, 1 ];\n\t\tmaterialParams.attenuationColor = new Color().setRGB( colorArray[ 0 ], colorArray[ 1 ], colorArray[ 2 ], LinearSRGBColorSpace );\n\n\t\treturn Promise.all( pending );\n\n\t}\n\n}\n\n/**\n * Materials ior Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_ior\n */\nclass GLTFMaterialsIorExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_IOR;\n\n\t}\n\n\tgetMaterialType( materialIndex ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;\n\n\t\treturn MeshPhysicalMaterial;\n\n\t}\n\n\textendMaterialParams( materialIndex, materialParams ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\n\n\t\t\treturn Promise.resolve();\n\n\t\t}\n\n\t\tconst extension = materialDef.extensions[ this.name ];\n\n\t\tmaterialParams.ior = extension.ior !== undefined ? extension.ior : 1.5;\n\n\t\treturn Promise.resolve();\n\n\t}\n\n}\n\n/**\n * Materials specular Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_specular\n */\nclass GLTFMaterialsSpecularExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_SPECULAR;\n\n\t}\n\n\tgetMaterialType( materialIndex ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;\n\n\t\treturn MeshPhysicalMaterial;\n\n\t}\n\n\textendMaterialParams( materialIndex, materialParams ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\n\n\t\t\treturn Promise.resolve();\n\n\t\t}\n\n\t\tconst pending = [];\n\n\t\tconst extension = materialDef.extensions[ this.name ];\n\n\t\tmaterialParams.specularIntensity = extension.specularFactor !== undefined ? extension.specularFactor : 1.0;\n\n\t\tif ( extension.specularTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'specularIntensityMap', extension.specularTexture ) );\n\n\t\t}\n\n\t\tconst colorArray = extension.specularColorFactor || [ 1, 1, 1 ];\n\t\tmaterialParams.specularColor = new Color().setRGB( colorArray[ 0 ], colorArray[ 1 ], colorArray[ 2 ], LinearSRGBColorSpace );\n\n\t\tif ( extension.specularColorTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'specularColorMap', extension.specularColorTexture, SRGBColorSpace ) );\n\n\t\t}\n\n\t\treturn Promise.all( pending );\n\n\t}\n\n}\n\n\n/**\n * Materials bump Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/EXT_materials_bump\n */\nclass GLTFMaterialsBumpExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.EXT_MATERIALS_BUMP;\n\n\t}\n\n\tgetMaterialType( materialIndex ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;\n\n\t\treturn MeshPhysicalMaterial;\n\n\t}\n\n\textendMaterialParams( materialIndex, materialParams ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\n\n\t\t\treturn Promise.resolve();\n\n\t\t}\n\n\t\tconst pending = [];\n\n\t\tconst extension = materialDef.extensions[ this.name ];\n\n\t\tmaterialParams.bumpScale = extension.bumpFactor !== undefined ? extension.bumpFactor : 1.0;\n\n\t\tif ( extension.bumpTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'bumpMap', extension.bumpTexture ) );\n\n\t\t}\n\n\t\treturn Promise.all( pending );\n\n\t}\n\n}\n\n/**\n * Materials anisotropy Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_anisotropy\n */\nclass GLTFMaterialsAnisotropyExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_ANISOTROPY;\n\n\t}\n\n\tgetMaterialType( materialIndex ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;\n\n\t\treturn MeshPhysicalMaterial;\n\n\t}\n\n\textendMaterialParams( materialIndex, materialParams ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\n\n\t\t\treturn Promise.resolve();\n\n\t\t}\n\n\t\tconst pending = [];\n\n\t\tconst extension = materialDef.extensions[ this.name ];\n\n\t\tif ( extension.anisotropyStrength !== undefined ) {\n\n\t\t\tmaterialParams.anisotropy = extension.anisotropyStrength;\n\n\t\t}\n\n\t\tif ( extension.anisotropyRotation !== undefined ) {\n\n\t\t\tmaterialParams.anisotropyRotation = extension.anisotropyRotation;\n\n\t\t}\n\n\t\tif ( extension.anisotropyTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'anisotropyMap', extension.anisotropyTexture ) );\n\n\t\t}\n\n\t\treturn Promise.all( pending );\n\n\t}\n\n}\n\n/**\n * BasisU Texture Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_basisu\n */\nclass GLTFTextureBasisUExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_TEXTURE_BASISU;\n\n\t}\n\n\tloadTexture( textureIndex ) {\n\n\t\tconst parser = this.parser;\n\t\tconst json = parser.json;\n\n\t\tconst textureDef = json.textures[ textureIndex ];\n\n\t\tif ( ! textureDef.extensions || ! textureDef.extensions[ this.name ] ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst extension = textureDef.extensions[ this.name ];\n\t\tconst loader = parser.options.ktx2Loader;\n\n\t\tif ( ! loader ) {\n\n\t\t\tif ( json.extensionsRequired && json.extensionsRequired.indexOf( this.name ) >= 0 ) {\n\n\t\t\t\tthrow new Error( 'THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures' );\n\n\t\t\t} else {\n\n\t\t\t\t// Assumes that the extension is optional and that a fallback texture is present\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn parser.loadTextureImage( textureIndex, extension.source, loader );\n\n\t}\n\n}\n\n/**\n * WebP Texture Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_texture_webp\n */\nclass GLTFTextureWebPExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.EXT_TEXTURE_WEBP;\n\t\tthis.isSupported = null;\n\n\t}\n\n\tloadTexture( textureIndex ) {\n\n\t\tconst name = this.name;\n\t\tconst parser = this.parser;\n\t\tconst json = parser.json;\n\n\t\tconst textureDef = json.textures[ textureIndex ];\n\n\t\tif ( ! textureDef.extensions || ! textureDef.extensions[ name ] ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst extension = textureDef.extensions[ name ];\n\t\tconst source = json.images[ extension.source ];\n\n\t\tlet loader = parser.textureLoader;\n\t\tif ( source.uri ) {\n\n\t\t\tconst handler = parser.options.manager.getHandler( source.uri );\n\t\t\tif ( handler !== null ) loader = handler;\n\n\t\t}\n\n\t\treturn this.detectSupport().then( function ( isSupported ) {\n\n\t\t\tif ( isSupported ) return parser.loadTextureImage( textureIndex, extension.source, loader );\n\n\t\t\tif ( json.extensionsRequired && json.extensionsRequired.indexOf( name ) >= 0 ) {\n\n\t\t\t\tthrow new Error( 'THREE.GLTFLoader: WebP required by asset but unsupported.' );\n\n\t\t\t}\n\n\t\t\t// Fall back to PNG or JPEG.\n\t\t\treturn parser.loadTexture( textureIndex );\n\n\t\t} );\n\n\t}\n\n\tdetectSupport() {\n\n\t\tif ( ! this.isSupported ) {\n\n\t\t\tthis.isSupported = new Promise( function ( resolve ) {\n\n\t\t\t\tconst image = new Image();\n\n\t\t\t\t// Lossy test image. Support for lossy images doesn't guarantee support for all\n\t\t\t\t// WebP images, unfortunately.\n\t\t\t\timage.src = 'data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA';\n\n\t\t\t\timage.onload = image.onerror = function () {\n\n\t\t\t\t\tresolve( image.height === 1 );\n\n\t\t\t\t};\n\n\t\t\t} );\n\n\t\t}\n\n\t\treturn this.isSupported;\n\n\t}\n\n}\n\n/**\n * AVIF Texture Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_texture_avif\n */\nclass GLTFTextureAVIFExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.EXT_TEXTURE_AVIF;\n\t\tthis.isSupported = null;\n\n\t}\n\n\tloadTexture( textureIndex ) {\n\n\t\tconst name = this.name;\n\t\tconst parser = this.parser;\n\t\tconst json = parser.json;\n\n\t\tconst textureDef = json.textures[ textureIndex ];\n\n\t\tif ( ! textureDef.extensions || ! textureDef.extensions[ name ] ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst extension = textureDef.extensions[ name ];\n\t\tconst source = json.images[ extension.source ];\n\n\t\tlet loader = parser.textureLoader;\n\t\tif ( source.uri ) {\n\n\t\t\tconst handler = parser.options.manager.getHandler( source.uri );\n\t\t\tif ( handler !== null ) loader = handler;\n\n\t\t}\n\n\t\treturn this.detectSupport().then( function ( isSupported ) {\n\n\t\t\tif ( isSupported ) return parser.loadTextureImage( textureIndex, extension.source, loader );\n\n\t\t\tif ( json.extensionsRequired && json.extensionsRequired.indexOf( name ) >= 0 ) {\n\n\t\t\t\tthrow new Error( 'THREE.GLTFLoader: AVIF required by asset but unsupported.' );\n\n\t\t\t}\n\n\t\t\t// Fall back to PNG or JPEG.\n\t\t\treturn parser.loadTexture( textureIndex );\n\n\t\t} );\n\n\t}\n\n\tdetectSupport() {\n\n\t\tif ( ! this.isSupported ) {\n\n\t\t\tthis.isSupported = new Promise( function ( resolve ) {\n\n\t\t\t\tconst image = new Image();\n\n\t\t\t\t// Lossy test image.\n\t\t\t\timage.src = 'data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=';\n\t\t\t\timage.onload = image.onerror = function () {\n\n\t\t\t\t\tresolve( image.height === 1 );\n\n\t\t\t\t};\n\n\t\t\t} );\n\n\t\t}\n\n\t\treturn this.isSupported;\n\n\t}\n\n}\n\n/**\n * meshopt BufferView Compression Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_meshopt_compression\n */\nclass GLTFMeshoptCompression {\n\n\tconstructor( parser ) {\n\n\t\tthis.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION;\n\t\tthis.parser = parser;\n\n\t}\n\n\tloadBufferView( index ) {\n\n\t\tconst json = this.parser.json;\n\t\tconst bufferView = json.bufferViews[ index ];\n\n\t\tif ( bufferView.extensions && bufferView.extensions[ this.name ] ) {\n\n\t\t\tconst extensionDef = bufferView.extensions[ this.name ];\n\n\t\t\tconst buffer = this.parser.getDependency( 'buffer', extensionDef.buffer );\n\t\t\tconst decoder = this.parser.options.meshoptDecoder;\n\n\t\t\tif ( ! decoder || ! decoder.supported ) {\n\n\t\t\t\tif ( json.extensionsRequired && json.extensionsRequired.indexOf( this.name ) >= 0 ) {\n\n\t\t\t\t\tthrow new Error( 'THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files' );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// Assumes that the extension is optional and that fallback buffer data is present\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn buffer.then( function ( res ) {\n\n\t\t\t\tconst byteOffset = extensionDef.byteOffset || 0;\n\t\t\t\tconst byteLength = extensionDef.byteLength || 0;\n\n\t\t\t\tconst count = extensionDef.count;\n\t\t\t\tconst stride = extensionDef.byteStride;\n\n\t\t\t\tconst source = new Uint8Array( res, byteOffset, byteLength );\n\n\t\t\t\tif ( decoder.decodeGltfBufferAsync ) {\n\n\t\t\t\t\treturn decoder.decodeGltfBufferAsync( count, stride, source, extensionDef.mode, extensionDef.filter ).then( function ( res ) {\n\n\t\t\t\t\t\treturn res.buffer;\n\n\t\t\t\t\t} );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// Support for MeshoptDecoder 0.18 or earlier, without decodeGltfBufferAsync\n\t\t\t\t\treturn decoder.ready.then( function () {\n\n\t\t\t\t\t\tconst result = new ArrayBuffer( count * stride );\n\t\t\t\t\t\tdecoder.decodeGltfBuffer( new Uint8Array( result ), count, stride, source, extensionDef.mode, extensionDef.filter );\n\t\t\t\t\t\treturn result;\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t} else {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * GPU Instancing Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_mesh_gpu_instancing\n *\n */\nclass GLTFMeshGpuInstancing {\n\n\tconstructor( parser ) {\n\n\t\tthis.name = EXTENSIONS.EXT_MESH_GPU_INSTANCING;\n\t\tthis.parser = parser;\n\n\t}\n\n\tcreateNodeMesh( nodeIndex ) {\n\n\t\tconst json = this.parser.json;\n\t\tconst nodeDef = json.nodes[ nodeIndex ];\n\n\t\tif ( ! nodeDef.extensions || ! nodeDef.extensions[ this.name ] ||\n\t\t\tnodeDef.mesh === undefined ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst meshDef = json.meshes[ nodeDef.mesh ];\n\n\t\t// No Points or Lines + Instancing support yet\n\n\t\tfor ( const primitive of meshDef.primitives ) {\n\n\t\t\tif ( primitive.mode !== WEBGL_CONSTANTS.TRIANGLES &&\n\t\t\t\t primitive.mode !== WEBGL_CONSTANTS.TRIANGLE_STRIP &&\n\t\t\t\t primitive.mode !== WEBGL_CONSTANTS.TRIANGLE_FAN &&\n\t\t\t\t primitive.mode !== undefined ) {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst extensionDef = nodeDef.extensions[ this.name ];\n\t\tconst attributesDef = extensionDef.attributes;\n\n\t\t// @TODO: Can we support InstancedMesh + SkinnedMesh?\n\n\t\tconst pending = [];\n\t\tconst attributes = {};\n\n\t\tfor ( const key in attributesDef ) {\n\n\t\t\tpending.push( this.parser.getDependency( 'accessor', attributesDef[ key ] ).then( accessor => {\n\n\t\t\t\tattributes[ key ] = accessor;\n\t\t\t\treturn attributes[ key ];\n\n\t\t\t} ) );\n\n\t\t}\n\n\t\tif ( pending.length < 1 ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tpending.push( this.parser.createNodeMesh( nodeIndex ) );\n\n\t\treturn Promise.all( pending ).then( results => {\n\n\t\t\tconst nodeObject = results.pop();\n\t\t\tconst meshes = nodeObject.isGroup ? nodeObject.children : [ nodeObject ];\n\t\t\tconst count = results[ 0 ].count; // All attribute counts should be same\n\t\t\tconst instancedMeshes = [];\n\n\t\t\tfor ( const mesh of meshes ) {\n\n\t\t\t\t// Temporal variables\n\t\t\t\tconst m = new Matrix4();\n\t\t\t\tconst p = new Vector3();\n\t\t\t\tconst q = new Quaternion();\n\t\t\t\tconst s = new Vector3( 1, 1, 1 );\n\n\t\t\t\tconst instancedMesh = new InstancedMesh( mesh.geometry, mesh.material, count );\n\n\t\t\t\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\t\t\t\tif ( attributes.TRANSLATION ) {\n\n\t\t\t\t\t\tp.fromBufferAttribute( attributes.TRANSLATION, i );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( attributes.ROTATION ) {\n\n\t\t\t\t\t\tq.fromBufferAttribute( attributes.ROTATION, i );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( attributes.SCALE ) {\n\n\t\t\t\t\t\ts.fromBufferAttribute( attributes.SCALE, i );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tinstancedMesh.setMatrixAt( i, m.compose( p, q, s ) );\n\n\t\t\t\t}\n\n\t\t\t\t// Add instance attributes to the geometry, excluding TRS.\n\t\t\t\tfor ( const attributeName in attributes ) {\n\n\t\t\t\t\tif ( attributeName === '_COLOR_0' ) {\n\n\t\t\t\t\t\tconst attr = attributes[ attributeName ];\n\t\t\t\t\t\tinstancedMesh.instanceColor = new InstancedBufferAttribute( attr.array, attr.itemSize, attr.normalized );\n\n\t\t\t\t\t} else if ( attributeName !== 'TRANSLATION' &&\n\t\t\t\t\t\t attributeName !== 'ROTATION' &&\n\t\t\t\t\t\t attributeName !== 'SCALE' ) {\n\n\t\t\t\t\t\tmesh.geometry.setAttribute( attributeName, attributes[ attributeName ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// Just in case\n\t\t\t\tObject3D.prototype.copy.call( instancedMesh, mesh );\n\n\t\t\t\tthis.parser.assignFinalMaterial( instancedMesh );\n\n\t\t\t\tinstancedMeshes.push( instancedMesh );\n\n\t\t\t}\n\n\t\t\tif ( nodeObject.isGroup ) {\n\n\t\t\t\tnodeObject.clear();\n\n\t\t\t\tnodeObject.add( ... instancedMeshes );\n\n\t\t\t\treturn nodeObject;\n\n\t\t\t}\n\n\t\t\treturn instancedMeshes[ 0 ];\n\n\t\t} );\n\n\t}\n\n}\n\n/* BINARY EXTENSION */\nconst BINARY_EXTENSION_HEADER_MAGIC = 'glTF';\nconst BINARY_EXTENSION_HEADER_LENGTH = 12;\nconst BINARY_EXTENSION_CHUNK_TYPES = { JSON: 0x4E4F534A, BIN: 0x004E4942 };\n\nclass GLTFBinaryExtension {\n\n\tconstructor( data ) {\n\n\t\tthis.name = EXTENSIONS.KHR_BINARY_GLTF;\n\t\tthis.content = null;\n\t\tthis.body = null;\n\n\t\tconst headerView = new DataView( data, 0, BINARY_EXTENSION_HEADER_LENGTH );\n\t\tconst textDecoder = new TextDecoder();\n\n\t\tthis.header = {\n\t\t\tmagic: textDecoder.decode( new Uint8Array( data.slice( 0, 4 ) ) ),\n\t\t\tversion: headerView.getUint32( 4, true ),\n\t\t\tlength: headerView.getUint32( 8, true )\n\t\t};\n\n\t\tif ( this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC ) {\n\n\t\t\tthrow new Error( 'THREE.GLTFLoader: Unsupported glTF-Binary header.' );\n\n\t\t} else if ( this.header.version < 2.0 ) {\n\n\t\t\tthrow new Error( 'THREE.GLTFLoader: Legacy binary file detected.' );\n\n\t\t}\n\n\t\tconst chunkContentsLength = this.header.length - BINARY_EXTENSION_HEADER_LENGTH;\n\t\tconst chunkView = new DataView( data, BINARY_EXTENSION_HEADER_LENGTH );\n\t\tlet chunkIndex = 0;\n\n\t\twhile ( chunkIndex < chunkContentsLength ) {\n\n\t\t\tconst chunkLength = chunkView.getUint32( chunkIndex, true );\n\t\t\tchunkIndex += 4;\n\n\t\t\tconst chunkType = chunkView.getUint32( chunkIndex, true );\n\t\t\tchunkIndex += 4;\n\n\t\t\tif ( chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON ) {\n\n\t\t\t\tconst contentArray = new Uint8Array( data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength );\n\t\t\t\tthis.content = textDecoder.decode( contentArray );\n\n\t\t\t} else if ( chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN ) {\n\n\t\t\t\tconst byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;\n\t\t\t\tthis.body = data.slice( byteOffset, byteOffset + chunkLength );\n\n\t\t\t}\n\n\t\t\t// Clients must ignore chunks with unknown types.\n\n\t\t\tchunkIndex += chunkLength;\n\n\t\t}\n\n\t\tif ( this.content === null ) {\n\n\t\t\tthrow new Error( 'THREE.GLTFLoader: JSON content not found.' );\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * DRACO Mesh Compression Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_draco_mesh_compression\n */\nclass GLTFDracoMeshCompressionExtension {\n\n\tconstructor( json, dracoLoader ) {\n\n\t\tif ( ! dracoLoader ) {\n\n\t\t\tthrow new Error( 'THREE.GLTFLoader: No DRACOLoader instance provided.' );\n\n\t\t}\n\n\t\tthis.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;\n\t\tthis.json = json;\n\t\tthis.dracoLoader = dracoLoader;\n\t\tthis.dracoLoader.preload();\n\n\t}\n\n\tdecodePrimitive( primitive, parser ) {\n\n\t\tconst json = this.json;\n\t\tconst dracoLoader = this.dracoLoader;\n\t\tconst bufferViewIndex = primitive.extensions[ this.name ].bufferView;\n\t\tconst gltfAttributeMap = primitive.extensions[ this.name ].attributes;\n\t\tconst threeAttributeMap = {};\n\t\tconst attributeNormalizedMap = {};\n\t\tconst attributeTypeMap = {};\n\n\t\tfor ( const attributeName in gltfAttributeMap ) {\n\n\t\t\tconst threeAttributeName = ATTRIBUTES[ attributeName ] || attributeName.toLowerCase();\n\n\t\t\tthreeAttributeMap[ threeAttributeName ] = gltfAttributeMap[ attributeName ];\n\n\t\t}\n\n\t\tfor ( const attributeName in primitive.attributes ) {\n\n\t\t\tconst threeAttributeName = ATTRIBUTES[ attributeName ] || attributeName.toLowerCase();\n\n\t\t\tif ( gltfAttributeMap[ attributeName ] !== undefined ) {\n\n\t\t\t\tconst accessorDef = json.accessors[ primitive.attributes[ attributeName ] ];\n\t\t\t\tconst componentType = WEBGL_COMPONENT_TYPES[ accessorDef.componentType ];\n\n\t\t\t\tattributeTypeMap[ threeAttributeName ] = componentType.name;\n\t\t\t\tattributeNormalizedMap[ threeAttributeName ] = accessorDef.normalized === true;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn parser.getDependency( 'bufferView', bufferViewIndex ).then( function ( bufferView ) {\n\n\t\t\treturn new Promise( function ( resolve, reject ) {\n\n\t\t\t\tdracoLoader.decodeDracoFile( bufferView, function ( geometry ) {\n\n\t\t\t\t\tfor ( const attributeName in geometry.attributes ) {\n\n\t\t\t\t\t\tconst attribute = geometry.attributes[ attributeName ];\n\t\t\t\t\t\tconst normalized = attributeNormalizedMap[ attributeName ];\n\n\t\t\t\t\t\tif ( normalized !== undefined ) attribute.normalized = normalized;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tresolve( geometry );\n\n\t\t\t\t}, threeAttributeMap, attributeTypeMap, LinearSRGBColorSpace, reject );\n\n\t\t\t} );\n\n\t\t} );\n\n\t}\n\n}\n\n/**\n * Texture Transform Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_transform\n */\nclass GLTFTextureTransformExtension {\n\n\tconstructor() {\n\n\t\tthis.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;\n\n\t}\n\n\textendTexture( texture, transform ) {\n\n\t\tif ( ( transform.texCoord === undefined || transform.texCoord === texture.channel )\n\t\t\t&& transform.offset === undefined\n\t\t\t&& transform.rotation === undefined\n\t\t\t&& transform.scale === undefined ) {\n\n\t\t\t// See https://github.com/mrdoob/three.js/issues/21819.\n\t\t\treturn texture;\n\n\t\t}\n\n\t\ttexture = texture.clone();\n\n\t\tif ( transform.texCoord !== undefined ) {\n\n\t\t\ttexture.channel = transform.texCoord;\n\n\t\t}\n\n\t\tif ( transform.offset !== undefined ) {\n\n\t\t\ttexture.offset.fromArray( transform.offset );\n\n\t\t}\n\n\t\tif ( transform.rotation !== undefined ) {\n\n\t\t\ttexture.rotation = transform.rotation;\n\n\t\t}\n\n\t\tif ( transform.scale !== undefined ) {\n\n\t\t\ttexture.repeat.fromArray( transform.scale );\n\n\t\t}\n\n\t\ttexture.needsUpdate = true;\n\n\t\treturn texture;\n\n\t}\n\n}\n\n/**\n * Mesh Quantization Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization\n */\nclass GLTFMeshQuantizationExtension {\n\n\tconstructor() {\n\n\t\tthis.name = EXTENSIONS.KHR_MESH_QUANTIZATION;\n\n\t}\n\n}\n\n/*********************************/\n/********** INTERPOLATION ********/\n/*********************************/\n\n// Spline Interpolation\n// Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#appendix-c-spline-interpolation\nclass GLTFCubicSplineInterpolant extends Interpolant {\n\n\tconstructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\t\tsuper( parameterPositions, sampleValues, sampleSize, resultBuffer );\n\n\t}\n\n\tcopySampleValue_( index ) {\n\n\t\t// Copies a sample value to the result buffer. See description of glTF\n\t\t// CUBICSPLINE values layout in interpolate_() function below.\n\n\t\tconst result = this.resultBuffer,\n\t\t\tvalues = this.sampleValues,\n\t\t\tvalueSize = this.valueSize,\n\t\t\toffset = index * valueSize * 3 + valueSize;\n\n\t\tfor ( let i = 0; i !== valueSize; i ++ ) {\n\n\t\t\tresult[ i ] = values[ offset + i ];\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\tinterpolate_( i1, t0, t, t1 ) {\n\n\t\tconst result = this.resultBuffer;\n\t\tconst values = this.sampleValues;\n\t\tconst stride = this.valueSize;\n\n\t\tconst stride2 = stride * 2;\n\t\tconst stride3 = stride * 3;\n\n\t\tconst td = t1 - t0;\n\n\t\tconst p = ( t - t0 ) / td;\n\t\tconst pp = p * p;\n\t\tconst ppp = pp * p;\n\n\t\tconst offset1 = i1 * stride3;\n\t\tconst offset0 = offset1 - stride3;\n\n\t\tconst s2 = - 2 * ppp + 3 * pp;\n\t\tconst s3 = ppp - pp;\n\t\tconst s0 = 1 - s2;\n\t\tconst s1 = s3 - pp + p;\n\n\t\t// Layout of keyframe output values for CUBICSPLINE animations:\n\t\t//   [ inTangent_1, splineVertex_1, outTangent_1, inTangent_2, splineVertex_2, ... ]\n\t\tfor ( let i = 0; i !== stride; i ++ ) {\n\n\t\t\tconst p0 = values[ offset0 + i + stride ]; // splineVertex_k\n\t\t\tconst m0 = values[ offset0 + i + stride2 ] * td; // outTangent_k * (t_k+1 - t_k)\n\t\t\tconst p1 = values[ offset1 + i + stride ]; // splineVertex_k+1\n\t\t\tconst m1 = values[ offset1 + i ] * td; // inTangent_k+1 * (t_k+1 - t_k)\n\n\t\t\tresult[ i ] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n}\n\nconst _q = new Quaternion();\n\nclass GLTFCubicSplineQuaternionInterpolant extends GLTFCubicSplineInterpolant {\n\n\tinterpolate_( i1, t0, t, t1 ) {\n\n\t\tconst result = super.interpolate_( i1, t0, t, t1 );\n\n\t\t_q.fromArray( result ).normalize().toArray( result );\n\n\t\treturn result;\n\n\t}\n\n}\n\n\n/*********************************/\n/********** INTERNALS ************/\n/*********************************/\n\n/* CONSTANTS */\n\nconst WEBGL_CONSTANTS = {\n\tFLOAT: 5126,\n\t//FLOAT_MAT2: 35674,\n\tFLOAT_MAT3: 35675,\n\tFLOAT_MAT4: 35676,\n\tFLOAT_VEC2: 35664,\n\tFLOAT_VEC3: 35665,\n\tFLOAT_VEC4: 35666,\n\tLINEAR: 9729,\n\tREPEAT: 10497,\n\tSAMPLER_2D: 35678,\n\tPOINTS: 0,\n\tLINES: 1,\n\tLINE_LOOP: 2,\n\tLINE_STRIP: 3,\n\tTRIANGLES: 4,\n\tTRIANGLE_STRIP: 5,\n\tTRIANGLE_FAN: 6,\n\tUNSIGNED_BYTE: 5121,\n\tUNSIGNED_SHORT: 5123\n};\n\nconst WEBGL_COMPONENT_TYPES = {\n\t5120: Int8Array,\n\t5121: Uint8Array,\n\t5122: Int16Array,\n\t5123: Uint16Array,\n\t5125: Uint32Array,\n\t5126: Float32Array\n};\n\nconst WEBGL_FILTERS = {\n\t9728: NearestFilter,\n\t9729: LinearFilter,\n\t9984: NearestMipmapNearestFilter,\n\t9985: LinearMipmapNearestFilter,\n\t9986: NearestMipmapLinearFilter,\n\t9987: LinearMipmapLinearFilter\n};\n\nconst WEBGL_WRAPPINGS = {\n\t33071: ClampToEdgeWrapping,\n\t33648: MirroredRepeatWrapping,\n\t10497: RepeatWrapping\n};\n\nconst WEBGL_TYPE_SIZES = {\n\t'SCALAR': 1,\n\t'VEC2': 2,\n\t'VEC3': 3,\n\t'VEC4': 4,\n\t'MAT2': 4,\n\t'MAT3': 9,\n\t'MAT4': 16\n};\n\nconst ATTRIBUTES = {\n\tPOSITION: 'position',\n\tNORMAL: 'normal',\n\tTANGENT: 'tangent',\n\tTEXCOORD_0: 'uv',\n\tTEXCOORD_1: 'uv1',\n\tTEXCOORD_2: 'uv2',\n\tTEXCOORD_3: 'uv3',\n\tCOLOR_0: 'color',\n\tWEIGHTS_0: 'skinWeight',\n\tJOINTS_0: 'skinIndex',\n};\n\nconst PATH_PROPERTIES = {\n\tscale: 'scale',\n\ttranslation: 'position',\n\trotation: 'quaternion',\n\tweights: 'morphTargetInfluences'\n};\n\nconst INTERPOLATION = {\n\tCUBICSPLINE: undefined, // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each\n\t\t                        // keyframe track will be initialized with a default interpolation type, then modified.\n\tLINEAR: InterpolateLinear,\n\tSTEP: InterpolateDiscrete\n};\n\nconst ALPHA_MODES = {\n\tOPAQUE: 'OPAQUE',\n\tMASK: 'MASK',\n\tBLEND: 'BLEND'\n};\n\n/**\n * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#default-material\n */\nfunction createDefaultMaterial( cache ) {\n\n\tif ( cache[ 'DefaultMaterial' ] === undefined ) {\n\n\t\tcache[ 'DefaultMaterial' ] = new MeshStandardMaterial( {\n\t\t\tcolor: 0xFFFFFF,\n\t\t\temissive: 0x000000,\n\t\t\tmetalness: 1,\n\t\t\troughness: 1,\n\t\t\ttransparent: false,\n\t\t\tdepthTest: true,\n\t\t\tside: FrontSide\n\t\t} );\n\n\t}\n\n\treturn cache[ 'DefaultMaterial' ];\n\n}\n\nfunction addUnknownExtensionsToUserData( knownExtensions, object, objectDef ) {\n\n\t// Add unknown glTF extensions to an object's userData.\n\n\tfor ( const name in objectDef.extensions ) {\n\n\t\tif ( knownExtensions[ name ] === undefined ) {\n\n\t\t\tobject.userData.gltfExtensions = object.userData.gltfExtensions || {};\n\t\t\tobject.userData.gltfExtensions[ name ] = objectDef.extensions[ name ];\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * @param {Object3D|Material|BufferGeometry} object\n * @param {GLTF.definition} gltfDef\n */\nfunction assignExtrasToUserData( object, gltfDef ) {\n\n\tif ( gltfDef.extras !== undefined ) {\n\n\t\tif ( typeof gltfDef.extras === 'object' ) {\n\n\t\t\tObject.assign( object.userData, gltfDef.extras );\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'THREE.GLTFLoader: Ignoring primitive type .extras, ' + gltfDef.extras );\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#morph-targets\n *\n * @param {BufferGeometry} geometry\n * @param {Array<GLTF.Target>} targets\n * @param {GLTFParser} parser\n * @return {Promise<BufferGeometry>}\n */\nfunction addMorphTargets( geometry, targets, parser ) {\n\n\tlet hasMorphPosition = false;\n\tlet hasMorphNormal = false;\n\tlet hasMorphColor = false;\n\n\tfor ( let i = 0, il = targets.length; i < il; i ++ ) {\n\n\t\tconst target = targets[ i ];\n\n\t\tif ( target.POSITION !== undefined ) hasMorphPosition = true;\n\t\tif ( target.NORMAL !== undefined ) hasMorphNormal = true;\n\t\tif ( target.COLOR_0 !== undefined ) hasMorphColor = true;\n\n\t\tif ( hasMorphPosition && hasMorphNormal && hasMorphColor ) break;\n\n\t}\n\n\tif ( ! hasMorphPosition && ! hasMorphNormal && ! hasMorphColor ) return Promise.resolve( geometry );\n\n\tconst pendingPositionAccessors = [];\n\tconst pendingNormalAccessors = [];\n\tconst pendingColorAccessors = [];\n\n\tfor ( let i = 0, il = targets.length; i < il; i ++ ) {\n\n\t\tconst target = targets[ i ];\n\n\t\tif ( hasMorphPosition ) {\n\n\t\t\tconst pendingAccessor = target.POSITION !== undefined\n\t\t\t\t? parser.getDependency( 'accessor', target.POSITION )\n\t\t\t\t: geometry.attributes.position;\n\n\t\t\tpendingPositionAccessors.push( pendingAccessor );\n\n\t\t}\n\n\t\tif ( hasMorphNormal ) {\n\n\t\t\tconst pendingAccessor = target.NORMAL !== undefined\n\t\t\t\t? parser.getDependency( 'accessor', target.NORMAL )\n\t\t\t\t: geometry.attributes.normal;\n\n\t\t\tpendingNormalAccessors.push( pendingAccessor );\n\n\t\t}\n\n\t\tif ( hasMorphColor ) {\n\n\t\t\tconst pendingAccessor = target.COLOR_0 !== undefined\n\t\t\t\t? parser.getDependency( 'accessor', target.COLOR_0 )\n\t\t\t\t: geometry.attributes.color;\n\n\t\t\tpendingColorAccessors.push( pendingAccessor );\n\n\t\t}\n\n\t}\n\n\treturn Promise.all( [\n\t\tPromise.all( pendingPositionAccessors ),\n\t\tPromise.all( pendingNormalAccessors ),\n\t\tPromise.all( pendingColorAccessors )\n\t] ).then( function ( accessors ) {\n\n\t\tconst morphPositions = accessors[ 0 ];\n\t\tconst morphNormals = accessors[ 1 ];\n\t\tconst morphColors = accessors[ 2 ];\n\n\t\tif ( hasMorphPosition ) geometry.morphAttributes.position = morphPositions;\n\t\tif ( hasMorphNormal ) geometry.morphAttributes.normal = morphNormals;\n\t\tif ( hasMorphColor ) geometry.morphAttributes.color = morphColors;\n\t\tgeometry.morphTargetsRelative = true;\n\n\t\treturn geometry;\n\n\t} );\n\n}\n\n/**\n * @param {Mesh} mesh\n * @param {GLTF.Mesh} meshDef\n */\nfunction updateMorphTargets( mesh, meshDef ) {\n\n\tmesh.updateMorphTargets();\n\n\tif ( meshDef.weights !== undefined ) {\n\n\t\tfor ( let i = 0, il = meshDef.weights.length; i < il; i ++ ) {\n\n\t\t\tmesh.morphTargetInfluences[ i ] = meshDef.weights[ i ];\n\n\t\t}\n\n\t}\n\n\t// .extras has user-defined data, so check that .extras.targetNames is an array.\n\tif ( meshDef.extras && Array.isArray( meshDef.extras.targetNames ) ) {\n\n\t\tconst targetNames = meshDef.extras.targetNames;\n\n\t\tif ( mesh.morphTargetInfluences.length === targetNames.length ) {\n\n\t\t\tmesh.morphTargetDictionary = {};\n\n\t\t\tfor ( let i = 0, il = targetNames.length; i < il; i ++ ) {\n\n\t\t\t\tmesh.morphTargetDictionary[ targetNames[ i ] ] = i;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.' );\n\n\t\t}\n\n\t}\n\n}\n\nfunction createPrimitiveKey( primitiveDef ) {\n\n\tlet geometryKey;\n\n\tconst dracoExtension = primitiveDef.extensions && primitiveDef.extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ];\n\n\tif ( dracoExtension ) {\n\n\t\tgeometryKey = 'draco:' + dracoExtension.bufferView\n\t\t\t\t+ ':' + dracoExtension.indices\n\t\t\t\t+ ':' + createAttributesKey( dracoExtension.attributes );\n\n\t} else {\n\n\t\tgeometryKey = primitiveDef.indices + ':' + createAttributesKey( primitiveDef.attributes ) + ':' + primitiveDef.mode;\n\n\t}\n\n\tif ( primitiveDef.targets !== undefined ) {\n\n\t\tfor ( let i = 0, il = primitiveDef.targets.length; i < il; i ++ ) {\n\n\t\t\tgeometryKey += ':' + createAttributesKey( primitiveDef.targets[ i ] );\n\n\t\t}\n\n\t}\n\n\treturn geometryKey;\n\n}\n\nfunction createAttributesKey( attributes ) {\n\n\tlet attributesKey = '';\n\n\tconst keys = Object.keys( attributes ).sort();\n\n\tfor ( let i = 0, il = keys.length; i < il; i ++ ) {\n\n\t\tattributesKey += keys[ i ] + ':' + attributes[ keys[ i ] ] + ';';\n\n\t}\n\n\treturn attributesKey;\n\n}\n\nfunction getNormalizedComponentScale( constructor ) {\n\n\t// Reference:\n\t// https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization#encoding-quantized-data\n\n\tswitch ( constructor ) {\n\n\t\tcase Int8Array:\n\t\t\treturn 1 / 127;\n\n\t\tcase Uint8Array:\n\t\t\treturn 1 / 255;\n\n\t\tcase Int16Array:\n\t\t\treturn 1 / 32767;\n\n\t\tcase Uint16Array:\n\t\t\treturn 1 / 65535;\n\n\t\tdefault:\n\t\t\tthrow new Error( 'THREE.GLTFLoader: Unsupported normalized accessor component type.' );\n\n\t}\n\n}\n\nfunction getImageURIMimeType( uri ) {\n\n\tif ( uri.search( /\\.jpe?g($|\\?)/i ) > 0 || uri.search( /^data\\:image\\/jpeg/ ) === 0 ) return 'image/jpeg';\n\tif ( uri.search( /\\.webp($|\\?)/i ) > 0 || uri.search( /^data\\:image\\/webp/ ) === 0 ) return 'image/webp';\n\n\treturn 'image/png';\n\n}\n\nconst _identityMatrix = new Matrix4();\n\n/* GLTF PARSER */\n\nclass GLTFParser {\n\n\tconstructor( json = {}, options = {} ) {\n\n\t\tthis.json = json;\n\t\tthis.extensions = {};\n\t\tthis.plugins = {};\n\t\tthis.options = options;\n\n\t\t// loader object cache\n\t\tthis.cache = new GLTFRegistry();\n\n\t\t// associations between Three.js objects and glTF elements\n\t\tthis.associations = new Map();\n\n\t\t// BufferGeometry caching\n\t\tthis.primitiveCache = {};\n\n\t\t// Node cache\n\t\tthis.nodeCache = {};\n\n\t\t// Object3D instance caches\n\t\tthis.meshCache = { refs: {}, uses: {} };\n\t\tthis.cameraCache = { refs: {}, uses: {} };\n\t\tthis.lightCache = { refs: {}, uses: {} };\n\n\t\tthis.sourceCache = {};\n\t\tthis.textureCache = {};\n\n\t\t// Track node names, to ensure no duplicates\n\t\tthis.nodeNamesUsed = {};\n\n\t\t// Use an ImageBitmapLoader if imageBitmaps are supported. Moves much of the\n\t\t// expensive work of uploading a texture to the GPU off the main thread.\n\n\t\tlet isSafari = false;\n\t\tlet isFirefox = false;\n\t\tlet firefoxVersion = - 1;\n\n\t\tif ( typeof navigator !== 'undefined' ) {\n\n\t\t\tisSafari = /^((?!chrome|android).)*safari/i.test( navigator.userAgent ) === true;\n\t\t\tisFirefox = navigator.userAgent.indexOf( 'Firefox' ) > - 1;\n\t\t\tfirefoxVersion = isFirefox ? navigator.userAgent.match( /Firefox\\/([0-9]+)\\./ )[ 1 ] : - 1;\n\n\t\t}\n\n\t\tif ( typeof createImageBitmap === 'undefined' || isSafari || ( isFirefox && firefoxVersion < 98 ) ) {\n\n\t\t\tthis.textureLoader = new TextureLoader( this.options.manager );\n\n\t\t} else {\n\n\t\t\tthis.textureLoader = new ImageBitmapLoader( this.options.manager );\n\n\t\t}\n\n\t\tthis.textureLoader.setCrossOrigin( this.options.crossOrigin );\n\t\tthis.textureLoader.setRequestHeader( this.options.requestHeader );\n\n\t\tthis.fileLoader = new FileLoader( this.options.manager );\n\t\tthis.fileLoader.setResponseType( 'arraybuffer' );\n\n\t\tif ( this.options.crossOrigin === 'use-credentials' ) {\n\n\t\t\tthis.fileLoader.setWithCredentials( true );\n\n\t\t}\n\n\t}\n\n\tsetExtensions( extensions ) {\n\n\t\tthis.extensions = extensions;\n\n\t}\n\n\tsetPlugins( plugins ) {\n\n\t\tthis.plugins = plugins;\n\n\t}\n\n\tparse( onLoad, onError ) {\n\n\t\tconst parser = this;\n\t\tconst json = this.json;\n\t\tconst extensions = this.extensions;\n\n\t\t// Clear the loader cache\n\t\tthis.cache.removeAll();\n\t\tthis.nodeCache = {};\n\n\t\t// Mark the special nodes/meshes in json for efficient parse\n\t\tthis._invokeAll( function ( ext ) {\n\n\t\t\treturn ext._markDefs && ext._markDefs();\n\n\t\t} );\n\n\t\tPromise.all( this._invokeAll( function ( ext ) {\n\n\t\t\treturn ext.beforeRoot && ext.beforeRoot();\n\n\t\t} ) ).then( function () {\n\n\t\t\treturn Promise.all( [\n\n\t\t\t\tparser.getDependencies( 'scene' ),\n\t\t\t\tparser.getDependencies( 'animation' ),\n\t\t\t\tparser.getDependencies( 'camera' ),\n\n\t\t\t] );\n\n\t\t} ).then( function ( dependencies ) {\n\n\t\t\tconst result = {\n\t\t\t\tscene: dependencies[ 0 ][ json.scene || 0 ],\n\t\t\t\tscenes: dependencies[ 0 ],\n\t\t\t\tanimations: dependencies[ 1 ],\n\t\t\t\tcameras: dependencies[ 2 ],\n\t\t\t\tasset: json.asset,\n\t\t\t\tparser: parser,\n\t\t\t\tuserData: {}\n\t\t\t};\n\n\t\t\taddUnknownExtensionsToUserData( extensions, result, json );\n\n\t\t\tassignExtrasToUserData( result, json );\n\n\t\t\treturn Promise.all( parser._invokeAll( function ( ext ) {\n\n\t\t\t\treturn ext.afterRoot && ext.afterRoot( result );\n\n\t\t\t} ) ).then( function () {\n\n\t\t\t\tfor ( const scene of result.scenes ) {\n\n\t\t\t\t\tscene.updateMatrixWorld();\n\n\t\t\t\t}\n\n\t\t\t\tonLoad( result );\n\n\t\t\t} );\n\n\t\t} ).catch( onError );\n\n\t}\n\n\t/**\n\t * Marks the special nodes/meshes in json for efficient parse.\n\t */\n\t_markDefs() {\n\n\t\tconst nodeDefs = this.json.nodes || [];\n\t\tconst skinDefs = this.json.skins || [];\n\t\tconst meshDefs = this.json.meshes || [];\n\n\t\t// Nothing in the node definition indicates whether it is a Bone or an\n\t\t// Object3D. Use the skins' joint references to mark bones.\n\t\tfor ( let skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex ++ ) {\n\n\t\t\tconst joints = skinDefs[ skinIndex ].joints;\n\n\t\t\tfor ( let i = 0, il = joints.length; i < il; i ++ ) {\n\n\t\t\t\tnodeDefs[ joints[ i ] ].isBone = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Iterate over all nodes, marking references to shared resources,\n\t\t// as well as skeleton joints.\n\t\tfor ( let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex ++ ) {\n\n\t\t\tconst nodeDef = nodeDefs[ nodeIndex ];\n\n\t\t\tif ( nodeDef.mesh !== undefined ) {\n\n\t\t\t\tthis._addNodeRef( this.meshCache, nodeDef.mesh );\n\n\t\t\t\t// Nothing in the mesh definition indicates whether it is\n\t\t\t\t// a SkinnedMesh or Mesh. Use the node's mesh reference\n\t\t\t\t// to mark SkinnedMesh if node has skin.\n\t\t\t\tif ( nodeDef.skin !== undefined ) {\n\n\t\t\t\t\tmeshDefs[ nodeDef.mesh ].isSkinnedMesh = true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( nodeDef.camera !== undefined ) {\n\n\t\t\t\tthis._addNodeRef( this.cameraCache, nodeDef.camera );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Counts references to shared node / Object3D resources. These resources\n\t * can be reused, or \"instantiated\", at multiple nodes in the scene\n\t * hierarchy. Mesh, Camera, and Light instances are instantiated and must\n\t * be marked. Non-scenegraph resources (like Materials, Geometries, and\n\t * Textures) can be reused directly and are not marked here.\n\t *\n\t * Example: CesiumMilkTruck sample model reuses \"Wheel\" meshes.\n\t */\n\t_addNodeRef( cache, index ) {\n\n\t\tif ( index === undefined ) return;\n\n\t\tif ( cache.refs[ index ] === undefined ) {\n\n\t\t\tcache.refs[ index ] = cache.uses[ index ] = 0;\n\n\t\t}\n\n\t\tcache.refs[ index ] ++;\n\n\t}\n\n\t/** Returns a reference to a shared resource, cloning it if necessary. */\n\t_getNodeRef( cache, index, object ) {\n\n\t\tif ( cache.refs[ index ] <= 1 ) return object;\n\n\t\tconst ref = object.clone();\n\n\t\t// Propagates mappings to the cloned object, prevents mappings on the\n\t\t// original object from being lost.\n\t\tconst updateMappings = ( original, clone ) => {\n\n\t\t\tconst mappings = this.associations.get( original );\n\t\t\tif ( mappings != null ) {\n\n\t\t\t\tthis.associations.set( clone, mappings );\n\n\t\t\t}\n\n\t\t\tfor ( const [ i, child ] of original.children.entries() ) {\n\n\t\t\t\tupdateMappings( child, clone.children[ i ] );\n\n\t\t\t}\n\n\t\t};\n\n\t\tupdateMappings( object, ref );\n\n\t\tref.name += '_instance_' + ( cache.uses[ index ] ++ );\n\n\t\treturn ref;\n\n\t}\n\n\t_invokeOne( func ) {\n\n\t\tconst extensions = Object.values( this.plugins );\n\t\textensions.push( this );\n\n\t\tfor ( let i = 0; i < extensions.length; i ++ ) {\n\n\t\t\tconst result = func( extensions[ i ] );\n\n\t\t\tif ( result ) return result;\n\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n\t_invokeAll( func ) {\n\n\t\tconst extensions = Object.values( this.plugins );\n\t\textensions.unshift( this );\n\n\t\tconst pending = [];\n\n\t\tfor ( let i = 0; i < extensions.length; i ++ ) {\n\n\t\t\tconst result = func( extensions[ i ] );\n\n\t\t\tif ( result ) pending.push( result );\n\n\t\t}\n\n\t\treturn pending;\n\n\t}\n\n\t/**\n\t * Requests the specified dependency asynchronously, with caching.\n\t * @param {string} type\n\t * @param {number} index\n\t * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}\n\t */\n\tgetDependency( type, index ) {\n\n\t\tconst cacheKey = type + ':' + index;\n\t\tlet dependency = this.cache.get( cacheKey );\n\n\t\tif ( ! dependency ) {\n\n\t\t\tswitch ( type ) {\n\n\t\t\t\tcase 'scene':\n\t\t\t\t\tdependency = this.loadScene( index );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'node':\n\t\t\t\t\tdependency = this._invokeOne( function ( ext ) {\n\n\t\t\t\t\t\treturn ext.loadNode && ext.loadNode( index );\n\n\t\t\t\t\t} );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'mesh':\n\t\t\t\t\tdependency = this._invokeOne( function ( ext ) {\n\n\t\t\t\t\t\treturn ext.loadMesh && ext.loadMesh( index );\n\n\t\t\t\t\t} );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'accessor':\n\t\t\t\t\tdependency = this.loadAccessor( index );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'bufferView':\n\t\t\t\t\tdependency = this._invokeOne( function ( ext ) {\n\n\t\t\t\t\t\treturn ext.loadBufferView && ext.loadBufferView( index );\n\n\t\t\t\t\t} );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'buffer':\n\t\t\t\t\tdependency = this.loadBuffer( index );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'material':\n\t\t\t\t\tdependency = this._invokeOne( function ( ext ) {\n\n\t\t\t\t\t\treturn ext.loadMaterial && ext.loadMaterial( index );\n\n\t\t\t\t\t} );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'texture':\n\t\t\t\t\tdependency = this._invokeOne( function ( ext ) {\n\n\t\t\t\t\t\treturn ext.loadTexture && ext.loadTexture( index );\n\n\t\t\t\t\t} );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'skin':\n\t\t\t\t\tdependency = this.loadSkin( index );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'animation':\n\t\t\t\t\tdependency = this._invokeOne( function ( ext ) {\n\n\t\t\t\t\t\treturn ext.loadAnimation && ext.loadAnimation( index );\n\n\t\t\t\t\t} );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'camera':\n\t\t\t\t\tdependency = this.loadCamera( index );\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tdependency = this._invokeOne( function ( ext ) {\n\n\t\t\t\t\t\treturn ext != this && ext.getDependency && ext.getDependency( type, index );\n\n\t\t\t\t\t} );\n\n\t\t\t\t\tif ( ! dependency ) {\n\n\t\t\t\t\t\tthrow new Error( 'Unknown type: ' + type );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tthis.cache.add( cacheKey, dependency );\n\n\t\t}\n\n\t\treturn dependency;\n\n\t}\n\n\t/**\n\t * Requests all dependencies of the specified type asynchronously, with caching.\n\t * @param {string} type\n\t * @return {Promise<Array<Object>>}\n\t */\n\tgetDependencies( type ) {\n\n\t\tlet dependencies = this.cache.get( type );\n\n\t\tif ( ! dependencies ) {\n\n\t\t\tconst parser = this;\n\t\t\tconst defs = this.json[ type + ( type === 'mesh' ? 'es' : 's' ) ] || [];\n\n\t\t\tdependencies = Promise.all( defs.map( function ( def, index ) {\n\n\t\t\t\treturn parser.getDependency( type, index );\n\n\t\t\t} ) );\n\n\t\t\tthis.cache.add( type, dependencies );\n\n\t\t}\n\n\t\treturn dependencies;\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n\t * @param {number} bufferIndex\n\t * @return {Promise<ArrayBuffer>}\n\t */\n\tloadBuffer( bufferIndex ) {\n\n\t\tconst bufferDef = this.json.buffers[ bufferIndex ];\n\t\tconst loader = this.fileLoader;\n\n\t\tif ( bufferDef.type && bufferDef.type !== 'arraybuffer' ) {\n\n\t\t\tthrow new Error( 'THREE.GLTFLoader: ' + bufferDef.type + ' buffer type is not supported.' );\n\n\t\t}\n\n\t\t// If present, GLB container is required to be the first buffer.\n\t\tif ( bufferDef.uri === undefined && bufferIndex === 0 ) {\n\n\t\t\treturn Promise.resolve( this.extensions[ EXTENSIONS.KHR_BINARY_GLTF ].body );\n\n\t\t}\n\n\t\tconst options = this.options;\n\n\t\treturn new Promise( function ( resolve, reject ) {\n\n\t\t\tloader.load( LoaderUtils.resolveURL( bufferDef.uri, options.path ), resolve, undefined, function () {\n\n\t\t\t\treject( new Error( 'THREE.GLTFLoader: Failed to load buffer \"' + bufferDef.uri + '\".' ) );\n\n\t\t\t} );\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n\t * @param {number} bufferViewIndex\n\t * @return {Promise<ArrayBuffer>}\n\t */\n\tloadBufferView( bufferViewIndex ) {\n\n\t\tconst bufferViewDef = this.json.bufferViews[ bufferViewIndex ];\n\n\t\treturn this.getDependency( 'buffer', bufferViewDef.buffer ).then( function ( buffer ) {\n\n\t\t\tconst byteLength = bufferViewDef.byteLength || 0;\n\t\t\tconst byteOffset = bufferViewDef.byteOffset || 0;\n\t\t\treturn buffer.slice( byteOffset, byteOffset + byteLength );\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors\n\t * @param {number} accessorIndex\n\t * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}\n\t */\n\tloadAccessor( accessorIndex ) {\n\n\t\tconst parser = this;\n\t\tconst json = this.json;\n\n\t\tconst accessorDef = this.json.accessors[ accessorIndex ];\n\n\t\tif ( accessorDef.bufferView === undefined && accessorDef.sparse === undefined ) {\n\n\t\t\tconst itemSize = WEBGL_TYPE_SIZES[ accessorDef.type ];\n\t\t\tconst TypedArray = WEBGL_COMPONENT_TYPES[ accessorDef.componentType ];\n\t\t\tconst normalized = accessorDef.normalized === true;\n\n\t\t\tconst array = new TypedArray( accessorDef.count * itemSize );\n\t\t\treturn Promise.resolve( new BufferAttribute( array, itemSize, normalized ) );\n\n\t\t}\n\n\t\tconst pendingBufferViews = [];\n\n\t\tif ( accessorDef.bufferView !== undefined ) {\n\n\t\t\tpendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.bufferView ) );\n\n\t\t} else {\n\n\t\t\tpendingBufferViews.push( null );\n\n\t\t}\n\n\t\tif ( accessorDef.sparse !== undefined ) {\n\n\t\t\tpendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.sparse.indices.bufferView ) );\n\t\t\tpendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.sparse.values.bufferView ) );\n\n\t\t}\n\n\t\treturn Promise.all( pendingBufferViews ).then( function ( bufferViews ) {\n\n\t\t\tconst bufferView = bufferViews[ 0 ];\n\n\t\t\tconst itemSize = WEBGL_TYPE_SIZES[ accessorDef.type ];\n\t\t\tconst TypedArray = WEBGL_COMPONENT_TYPES[ accessorDef.componentType ];\n\n\t\t\t// For VEC3: itemSize is 3, elementBytes is 4, itemBytes is 12.\n\t\t\tconst elementBytes = TypedArray.BYTES_PER_ELEMENT;\n\t\t\tconst itemBytes = elementBytes * itemSize;\n\t\t\tconst byteOffset = accessorDef.byteOffset || 0;\n\t\t\tconst byteStride = accessorDef.bufferView !== undefined ? json.bufferViews[ accessorDef.bufferView ].byteStride : undefined;\n\t\t\tconst normalized = accessorDef.normalized === true;\n\t\t\tlet array, bufferAttribute;\n\n\t\t\t// The buffer is not interleaved if the stride is the item size in bytes.\n\t\t\tif ( byteStride && byteStride !== itemBytes ) {\n\n\t\t\t\t// Each \"slice\" of the buffer, as defined by 'count' elements of 'byteStride' bytes, gets its own InterleavedBuffer\n\t\t\t\t// This makes sure that IBA.count reflects accessor.count properly\n\t\t\t\tconst ibSlice = Math.floor( byteOffset / byteStride );\n\t\t\t\tconst ibCacheKey = 'InterleavedBuffer:' + accessorDef.bufferView + ':' + accessorDef.componentType + ':' + ibSlice + ':' + accessorDef.count;\n\t\t\t\tlet ib = parser.cache.get( ibCacheKey );\n\n\t\t\t\tif ( ! ib ) {\n\n\t\t\t\t\tarray = new TypedArray( bufferView, ibSlice * byteStride, accessorDef.count * byteStride / elementBytes );\n\n\t\t\t\t\t// Integer parameters to IB/IBA are in array elements, not bytes.\n\t\t\t\t\tib = new InterleavedBuffer( array, byteStride / elementBytes );\n\n\t\t\t\t\tparser.cache.add( ibCacheKey, ib );\n\n\t\t\t\t}\n\n\t\t\t\tbufferAttribute = new InterleavedBufferAttribute( ib, itemSize, ( byteOffset % byteStride ) / elementBytes, normalized );\n\n\t\t\t} else {\n\n\t\t\t\tif ( bufferView === null ) {\n\n\t\t\t\t\tarray = new TypedArray( accessorDef.count * itemSize );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tarray = new TypedArray( bufferView, byteOffset, accessorDef.count * itemSize );\n\n\t\t\t\t}\n\n\t\t\t\tbufferAttribute = new BufferAttribute( array, itemSize, normalized );\n\n\t\t\t}\n\n\t\t\t// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#sparse-accessors\n\t\t\tif ( accessorDef.sparse !== undefined ) {\n\n\t\t\t\tconst itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;\n\t\t\t\tconst TypedArrayIndices = WEBGL_COMPONENT_TYPES[ accessorDef.sparse.indices.componentType ];\n\n\t\t\t\tconst byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;\n\t\t\t\tconst byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;\n\n\t\t\t\tconst sparseIndices = new TypedArrayIndices( bufferViews[ 1 ], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices );\n\t\t\t\tconst sparseValues = new TypedArray( bufferViews[ 2 ], byteOffsetValues, accessorDef.sparse.count * itemSize );\n\n\t\t\t\tif ( bufferView !== null ) {\n\n\t\t\t\t\t// Avoid modifying the original ArrayBuffer, if the bufferView wasn't initialized with zeroes.\n\t\t\t\t\tbufferAttribute = new BufferAttribute( bufferAttribute.array.slice(), bufferAttribute.itemSize, bufferAttribute.normalized );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( let i = 0, il = sparseIndices.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst index = sparseIndices[ i ];\n\n\t\t\t\t\tbufferAttribute.setX( index, sparseValues[ i * itemSize ] );\n\t\t\t\t\tif ( itemSize >= 2 ) bufferAttribute.setY( index, sparseValues[ i * itemSize + 1 ] );\n\t\t\t\t\tif ( itemSize >= 3 ) bufferAttribute.setZ( index, sparseValues[ i * itemSize + 2 ] );\n\t\t\t\t\tif ( itemSize >= 4 ) bufferAttribute.setW( index, sparseValues[ i * itemSize + 3 ] );\n\t\t\t\t\tif ( itemSize >= 5 ) throw new Error( 'THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn bufferAttribute;\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures\n\t * @param {number} textureIndex\n\t * @return {Promise<THREE.Texture|null>}\n\t */\n\tloadTexture( textureIndex ) {\n\n\t\tconst json = this.json;\n\t\tconst options = this.options;\n\t\tconst textureDef = json.textures[ textureIndex ];\n\t\tconst sourceIndex = textureDef.source;\n\t\tconst sourceDef = json.images[ sourceIndex ];\n\n\t\tlet loader = this.textureLoader;\n\n\t\tif ( sourceDef.uri ) {\n\n\t\t\tconst handler = options.manager.getHandler( sourceDef.uri );\n\t\t\tif ( handler !== null ) loader = handler;\n\n\t\t}\n\n\t\treturn this.loadTextureImage( textureIndex, sourceIndex, loader );\n\n\t}\n\n\tloadTextureImage( textureIndex, sourceIndex, loader ) {\n\n\t\tconst parser = this;\n\t\tconst json = this.json;\n\n\t\tconst textureDef = json.textures[ textureIndex ];\n\t\tconst sourceDef = json.images[ sourceIndex ];\n\n\t\tconst cacheKey = ( sourceDef.uri || sourceDef.bufferView ) + ':' + textureDef.sampler;\n\n\t\tif ( this.textureCache[ cacheKey ] ) {\n\n\t\t\t// See https://github.com/mrdoob/three.js/issues/21559.\n\t\t\treturn this.textureCache[ cacheKey ];\n\n\t\t}\n\n\t\tconst promise = this.loadImageSource( sourceIndex, loader ).then( function ( texture ) {\n\n\t\t\ttexture.flipY = false;\n\n\t\t\ttexture.name = textureDef.name || sourceDef.name || '';\n\n\t\t\tif ( texture.name === '' && typeof sourceDef.uri === 'string' && sourceDef.uri.startsWith( 'data:image/' ) === false ) {\n\n\t\t\t\ttexture.name = sourceDef.uri;\n\n\t\t\t}\n\n\t\t\tconst samplers = json.samplers || {};\n\t\t\tconst sampler = samplers[ textureDef.sampler ] || {};\n\n\t\t\ttexture.magFilter = WEBGL_FILTERS[ sampler.magFilter ] || LinearFilter;\n\t\t\ttexture.minFilter = WEBGL_FILTERS[ sampler.minFilter ] || LinearMipmapLinearFilter;\n\t\t\ttexture.wrapS = WEBGL_WRAPPINGS[ sampler.wrapS ] || RepeatWrapping;\n\t\t\ttexture.wrapT = WEBGL_WRAPPINGS[ sampler.wrapT ] || RepeatWrapping;\n\n\t\t\tparser.associations.set( texture, { textures: textureIndex } );\n\n\t\t\treturn texture;\n\n\t\t} ).catch( function () {\n\n\t\t\treturn null;\n\n\t\t} );\n\n\t\tthis.textureCache[ cacheKey ] = promise;\n\n\t\treturn promise;\n\n\t}\n\n\tloadImageSource( sourceIndex, loader ) {\n\n\t\tconst parser = this;\n\t\tconst json = this.json;\n\t\tconst options = this.options;\n\n\t\tif ( this.sourceCache[ sourceIndex ] !== undefined ) {\n\n\t\t\treturn this.sourceCache[ sourceIndex ].then( ( texture ) => texture.clone() );\n\n\t\t}\n\n\t\tconst sourceDef = json.images[ sourceIndex ];\n\n\t\tconst URL = self.URL || self.webkitURL;\n\n\t\tlet sourceURI = sourceDef.uri || '';\n\t\tlet isObjectURL = false;\n\n\t\tif ( sourceDef.bufferView !== undefined ) {\n\n\t\t\t// Load binary image data from bufferView, if provided.\n\n\t\t\tsourceURI = parser.getDependency( 'bufferView', sourceDef.bufferView ).then( function ( bufferView ) {\n\n\t\t\t\tisObjectURL = true;\n\t\t\t\tconst blob = new Blob( [ bufferView ], { type: sourceDef.mimeType } );\n\t\t\t\tsourceURI = URL.createObjectURL( blob );\n\t\t\t\treturn sourceURI;\n\n\t\t\t} );\n\n\t\t} else if ( sourceDef.uri === undefined ) {\n\n\t\t\tthrow new Error( 'THREE.GLTFLoader: Image ' + sourceIndex + ' is missing URI and bufferView' );\n\n\t\t}\n\n\t\tconst promise = Promise.resolve( sourceURI ).then( function ( sourceURI ) {\n\n\t\t\treturn new Promise( function ( resolve, reject ) {\n\n\t\t\t\tlet onLoad = resolve;\n\n\t\t\t\tif ( loader.isImageBitmapLoader === true ) {\n\n\t\t\t\t\tonLoad = function ( imageBitmap ) {\n\n\t\t\t\t\t\tconst texture = new Texture( imageBitmap );\n\t\t\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\t\t\tresolve( texture );\n\n\t\t\t\t\t};\n\n\t\t\t\t}\n\n\t\t\t\tloader.load( LoaderUtils.resolveURL( sourceURI, options.path ), onLoad, undefined, reject );\n\n\t\t\t} );\n\n\t\t} ).then( function ( texture ) {\n\n\t\t\t// Clean up resources and configure Texture.\n\n\t\t\tif ( isObjectURL === true ) {\n\n\t\t\t\tURL.revokeObjectURL( sourceURI );\n\n\t\t\t}\n\n\t\t\tassignExtrasToUserData( texture, sourceDef );\n\n\t\t\ttexture.userData.mimeType = sourceDef.mimeType || getImageURIMimeType( sourceDef.uri );\n\n\t\t\treturn texture;\n\n\t\t} ).catch( function ( error ) {\n\n\t\t\tconsole.error( 'THREE.GLTFLoader: Couldn\\'t load texture', sourceURI );\n\t\t\tthrow error;\n\n\t\t} );\n\n\t\tthis.sourceCache[ sourceIndex ] = promise;\n\t\treturn promise;\n\n\t}\n\n\t/**\n\t * Asynchronously assigns a texture to the given material parameters.\n\t * @param {Object} materialParams\n\t * @param {string} mapName\n\t * @param {Object} mapDef\n\t * @return {Promise<Texture>}\n\t */\n\tassignTexture( materialParams, mapName, mapDef, colorSpace ) {\n\n\t\tconst parser = this;\n\n\t\treturn this.getDependency( 'texture', mapDef.index ).then( function ( texture ) {\n\n\t\t\tif ( ! texture ) return null;\n\n\t\t\tif ( mapDef.texCoord !== undefined && mapDef.texCoord > 0 ) {\n\n\t\t\t\ttexture = texture.clone();\n\t\t\t\ttexture.channel = mapDef.texCoord;\n\n\t\t\t}\n\n\t\t\tif ( parser.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ] ) {\n\n\t\t\t\tconst transform = mapDef.extensions !== undefined ? mapDef.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ] : undefined;\n\n\t\t\t\tif ( transform ) {\n\n\t\t\t\t\tconst gltfReference = parser.associations.get( texture );\n\t\t\t\t\ttexture = parser.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ].extendTexture( texture, transform );\n\t\t\t\t\tparser.associations.set( texture, gltfReference );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( colorSpace !== undefined ) {\n\n\t\t\t\ttexture.colorSpace = colorSpace;\n\n\t\t\t}\n\n\t\t\tmaterialParams[ mapName ] = texture;\n\n\t\t\treturn texture;\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Assigns final material to a Mesh, Line, or Points instance. The instance\n\t * already has a material (generated from the glTF material options alone)\n\t * but reuse of the same glTF material may require multiple threejs materials\n\t * to accommodate different primitive types, defines, etc. New materials will\n\t * be created if necessary, and reused from a cache.\n\t * @param  {Object3D} mesh Mesh, Line, or Points instance.\n\t */\n\tassignFinalMaterial( mesh ) {\n\n\t\tconst geometry = mesh.geometry;\n\t\tlet material = mesh.material;\n\n\t\tconst useDerivativeTangents = geometry.attributes.tangent === undefined;\n\t\tconst useVertexColors = geometry.attributes.color !== undefined;\n\t\tconst useFlatShading = geometry.attributes.normal === undefined;\n\n\t\tif ( mesh.isPoints ) {\n\n\t\t\tconst cacheKey = 'PointsMaterial:' + material.uuid;\n\n\t\t\tlet pointsMaterial = this.cache.get( cacheKey );\n\n\t\t\tif ( ! pointsMaterial ) {\n\n\t\t\t\tpointsMaterial = new PointsMaterial();\n\t\t\t\tMaterial.prototype.copy.call( pointsMaterial, material );\n\t\t\t\tpointsMaterial.color.copy( material.color );\n\t\t\t\tpointsMaterial.map = material.map;\n\t\t\t\tpointsMaterial.sizeAttenuation = false; // glTF spec says points should be 1px\n\n\t\t\t\tthis.cache.add( cacheKey, pointsMaterial );\n\n\t\t\t}\n\n\t\t\tmaterial = pointsMaterial;\n\n\t\t} else if ( mesh.isLine ) {\n\n\t\t\tconst cacheKey = 'LineBasicMaterial:' + material.uuid;\n\n\t\t\tlet lineMaterial = this.cache.get( cacheKey );\n\n\t\t\tif ( ! lineMaterial ) {\n\n\t\t\t\tlineMaterial = new LineBasicMaterial();\n\t\t\t\tMaterial.prototype.copy.call( lineMaterial, material );\n\t\t\t\tlineMaterial.color.copy( material.color );\n\t\t\t\tlineMaterial.map = material.map;\n\n\t\t\t\tthis.cache.add( cacheKey, lineMaterial );\n\n\t\t\t}\n\n\t\t\tmaterial = lineMaterial;\n\n\t\t}\n\n\t\t// Clone the material if it will be modified\n\t\tif ( useDerivativeTangents || useVertexColors || useFlatShading ) {\n\n\t\t\tlet cacheKey = 'ClonedMaterial:' + material.uuid + ':';\n\n\t\t\tif ( useDerivativeTangents ) cacheKey += 'derivative-tangents:';\n\t\t\tif ( useVertexColors ) cacheKey += 'vertex-colors:';\n\t\t\tif ( useFlatShading ) cacheKey += 'flat-shading:';\n\n\t\t\tlet cachedMaterial = this.cache.get( cacheKey );\n\n\t\t\tif ( ! cachedMaterial ) {\n\n\t\t\t\tcachedMaterial = material.clone();\n\n\t\t\t\tif ( useVertexColors ) cachedMaterial.vertexColors = true;\n\t\t\t\tif ( useFlatShading ) cachedMaterial.flatShading = true;\n\n\t\t\t\tif ( useDerivativeTangents ) {\n\n\t\t\t\t\t// https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995\n\t\t\t\t\tif ( cachedMaterial.normalScale ) cachedMaterial.normalScale.y *= - 1;\n\t\t\t\t\tif ( cachedMaterial.clearcoatNormalScale ) cachedMaterial.clearcoatNormalScale.y *= - 1;\n\n\t\t\t\t}\n\n\t\t\t\tthis.cache.add( cacheKey, cachedMaterial );\n\n\t\t\t\tthis.associations.set( cachedMaterial, this.associations.get( material ) );\n\n\t\t\t}\n\n\t\t\tmaterial = cachedMaterial;\n\n\t\t}\n\n\t\tmesh.material = material;\n\n\t}\n\n\tgetMaterialType( /* materialIndex */ ) {\n\n\t\treturn MeshStandardMaterial;\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials\n\t * @param {number} materialIndex\n\t * @return {Promise<Material>}\n\t */\n\tloadMaterial( materialIndex ) {\n\n\t\tconst parser = this;\n\t\tconst json = this.json;\n\t\tconst extensions = this.extensions;\n\t\tconst materialDef = json.materials[ materialIndex ];\n\n\t\tlet materialType;\n\t\tconst materialParams = {};\n\t\tconst materialExtensions = materialDef.extensions || {};\n\n\t\tconst pending = [];\n\n\t\tif ( materialExtensions[ EXTENSIONS.KHR_MATERIALS_UNLIT ] ) {\n\n\t\t\tconst kmuExtension = extensions[ EXTENSIONS.KHR_MATERIALS_UNLIT ];\n\t\t\tmaterialType = kmuExtension.getMaterialType();\n\t\t\tpending.push( kmuExtension.extendParams( materialParams, materialDef, parser ) );\n\n\t\t} else {\n\n\t\t\t// Specification:\n\t\t\t// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#metallic-roughness-material\n\n\t\t\tconst metallicRoughness = materialDef.pbrMetallicRoughness || {};\n\n\t\t\tmaterialParams.color = new Color( 1.0, 1.0, 1.0 );\n\t\t\tmaterialParams.opacity = 1.0;\n\n\t\t\tif ( Array.isArray( metallicRoughness.baseColorFactor ) ) {\n\n\t\t\t\tconst array = metallicRoughness.baseColorFactor;\n\n\t\t\t\tmaterialParams.color.setRGB( array[ 0 ], array[ 1 ], array[ 2 ], LinearSRGBColorSpace );\n\t\t\t\tmaterialParams.opacity = array[ 3 ];\n\n\t\t\t}\n\n\t\t\tif ( metallicRoughness.baseColorTexture !== undefined ) {\n\n\t\t\t\tpending.push( parser.assignTexture( materialParams, 'map', metallicRoughness.baseColorTexture, SRGBColorSpace ) );\n\n\t\t\t}\n\n\t\t\tmaterialParams.metalness = metallicRoughness.metallicFactor !== undefined ? metallicRoughness.metallicFactor : 1.0;\n\t\t\tmaterialParams.roughness = metallicRoughness.roughnessFactor !== undefined ? metallicRoughness.roughnessFactor : 1.0;\n\n\t\t\tif ( metallicRoughness.metallicRoughnessTexture !== undefined ) {\n\n\t\t\t\tpending.push( parser.assignTexture( materialParams, 'metalnessMap', metallicRoughness.metallicRoughnessTexture ) );\n\t\t\t\tpending.push( parser.assignTexture( materialParams, 'roughnessMap', metallicRoughness.metallicRoughnessTexture ) );\n\n\t\t\t}\n\n\t\t\tmaterialType = this._invokeOne( function ( ext ) {\n\n\t\t\t\treturn ext.getMaterialType && ext.getMaterialType( materialIndex );\n\n\t\t\t} );\n\n\t\t\tpending.push( Promise.all( this._invokeAll( function ( ext ) {\n\n\t\t\t\treturn ext.extendMaterialParams && ext.extendMaterialParams( materialIndex, materialParams );\n\n\t\t\t} ) ) );\n\n\t\t}\n\n\t\tif ( materialDef.doubleSided === true ) {\n\n\t\t\tmaterialParams.side = DoubleSide;\n\n\t\t}\n\n\t\tconst alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;\n\n\t\tif ( alphaMode === ALPHA_MODES.BLEND ) {\n\n\t\t\tmaterialParams.transparent = true;\n\n\t\t\t// See: https://github.com/mrdoob/three.js/issues/17706\n\t\t\tmaterialParams.depthWrite = false;\n\n\t\t} else {\n\n\t\t\tmaterialParams.transparent = false;\n\n\t\t\tif ( alphaMode === ALPHA_MODES.MASK ) {\n\n\t\t\t\tmaterialParams.alphaTest = materialDef.alphaCutoff !== undefined ? materialDef.alphaCutoff : 0.5;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( materialDef.normalTexture !== undefined && materialType !== MeshBasicMaterial ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'normalMap', materialDef.normalTexture ) );\n\n\t\t\tmaterialParams.normalScale = new Vector2( 1, 1 );\n\n\t\t\tif ( materialDef.normalTexture.scale !== undefined ) {\n\n\t\t\t\tconst scale = materialDef.normalTexture.scale;\n\n\t\t\t\tmaterialParams.normalScale.set( scale, scale );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( materialDef.occlusionTexture !== undefined && materialType !== MeshBasicMaterial ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'aoMap', materialDef.occlusionTexture ) );\n\n\t\t\tif ( materialDef.occlusionTexture.strength !== undefined ) {\n\n\t\t\t\tmaterialParams.aoMapIntensity = materialDef.occlusionTexture.strength;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( materialDef.emissiveFactor !== undefined && materialType !== MeshBasicMaterial ) {\n\n\t\t\tconst emissiveFactor = materialDef.emissiveFactor;\n\t\t\tmaterialParams.emissive = new Color().setRGB( emissiveFactor[ 0 ], emissiveFactor[ 1 ], emissiveFactor[ 2 ], LinearSRGBColorSpace );\n\n\t\t}\n\n\t\tif ( materialDef.emissiveTexture !== undefined && materialType !== MeshBasicMaterial ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'emissiveMap', materialDef.emissiveTexture, SRGBColorSpace ) );\n\n\t\t}\n\n\t\treturn Promise.all( pending ).then( function () {\n\n\t\t\tconst material = new materialType( materialParams );\n\n\t\t\tif ( materialDef.name ) material.name = materialDef.name;\n\n\t\t\tassignExtrasToUserData( material, materialDef );\n\n\t\t\tparser.associations.set( material, { materials: materialIndex } );\n\n\t\t\tif ( materialDef.extensions ) addUnknownExtensionsToUserData( extensions, material, materialDef );\n\n\t\t\treturn material;\n\n\t\t} );\n\n\t}\n\n\t/** When Object3D instances are targeted by animation, they need unique names. */\n\tcreateUniqueName( originalName ) {\n\n\t\tconst sanitizedName = PropertyBinding.sanitizeNodeName( originalName || '' );\n\n\t\tif ( sanitizedName in this.nodeNamesUsed ) {\n\n\t\t\treturn sanitizedName + '_' + ( ++ this.nodeNamesUsed[ sanitizedName ] );\n\n\t\t} else {\n\n\t\t\tthis.nodeNamesUsed[ sanitizedName ] = 0;\n\n\t\t\treturn sanitizedName;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry\n\t *\n\t * Creates BufferGeometries from primitives.\n\t *\n\t * @param {Array<GLTF.Primitive>} primitives\n\t * @return {Promise<Array<BufferGeometry>>}\n\t */\n\tloadGeometries( primitives ) {\n\n\t\tconst parser = this;\n\t\tconst extensions = this.extensions;\n\t\tconst cache = this.primitiveCache;\n\n\t\tfunction createDracoPrimitive( primitive ) {\n\n\t\t\treturn extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ]\n\t\t\t\t.decodePrimitive( primitive, parser )\n\t\t\t\t.then( function ( geometry ) {\n\n\t\t\t\t\treturn addPrimitiveAttributes( geometry, primitive, parser );\n\n\t\t\t\t} );\n\n\t\t}\n\n\t\tconst pending = [];\n\n\t\tfor ( let i = 0, il = primitives.length; i < il; i ++ ) {\n\n\t\t\tconst primitive = primitives[ i ];\n\t\t\tconst cacheKey = createPrimitiveKey( primitive );\n\n\t\t\t// See if we've already created this geometry\n\t\t\tconst cached = cache[ cacheKey ];\n\n\t\t\tif ( cached ) {\n\n\t\t\t\t// Use the cached geometry if it exists\n\t\t\t\tpending.push( cached.promise );\n\n\t\t\t} else {\n\n\t\t\t\tlet geometryPromise;\n\n\t\t\t\tif ( primitive.extensions && primitive.extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ] ) {\n\n\t\t\t\t\t// Use DRACO geometry if available\n\t\t\t\t\tgeometryPromise = createDracoPrimitive( primitive );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// Otherwise create a new geometry\n\t\t\t\t\tgeometryPromise = addPrimitiveAttributes( new BufferGeometry(), primitive, parser );\n\n\t\t\t\t}\n\n\t\t\t\t// Cache this geometry\n\t\t\t\tcache[ cacheKey ] = { primitive: primitive, promise: geometryPromise };\n\n\t\t\t\tpending.push( geometryPromise );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn Promise.all( pending );\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes\n\t * @param {number} meshIndex\n\t * @return {Promise<Group|Mesh|SkinnedMesh>}\n\t */\n\tloadMesh( meshIndex ) {\n\n\t\tconst parser = this;\n\t\tconst json = this.json;\n\t\tconst extensions = this.extensions;\n\n\t\tconst meshDef = json.meshes[ meshIndex ];\n\t\tconst primitives = meshDef.primitives;\n\n\t\tconst pending = [];\n\n\t\tfor ( let i = 0, il = primitives.length; i < il; i ++ ) {\n\n\t\t\tconst material = primitives[ i ].material === undefined\n\t\t\t\t? createDefaultMaterial( this.cache )\n\t\t\t\t: this.getDependency( 'material', primitives[ i ].material );\n\n\t\t\tpending.push( material );\n\n\t\t}\n\n\t\tpending.push( parser.loadGeometries( primitives ) );\n\n\t\treturn Promise.all( pending ).then( function ( results ) {\n\n\t\t\tconst materials = results.slice( 0, results.length - 1 );\n\t\t\tconst geometries = results[ results.length - 1 ];\n\n\t\t\tconst meshes = [];\n\n\t\t\tfor ( let i = 0, il = geometries.length; i < il; i ++ ) {\n\n\t\t\t\tconst geometry = geometries[ i ];\n\t\t\t\tconst primitive = primitives[ i ];\n\n\t\t\t\t// 1. create Mesh\n\n\t\t\t\tlet mesh;\n\n\t\t\t\tconst material = materials[ i ];\n\n\t\t\t\tif ( primitive.mode === WEBGL_CONSTANTS.TRIANGLES ||\n\t\t\t\t\t\tprimitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP ||\n\t\t\t\t\t\tprimitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN ||\n\t\t\t\t\t\tprimitive.mode === undefined ) {\n\n\t\t\t\t\t// .isSkinnedMesh isn't in glTF spec. See ._markDefs()\n\t\t\t\t\tmesh = meshDef.isSkinnedMesh === true\n\t\t\t\t\t\t? new SkinnedMesh( geometry, material )\n\t\t\t\t\t\t: new Mesh( geometry, material );\n\n\t\t\t\t\tif ( mesh.isSkinnedMesh === true ) {\n\n\t\t\t\t\t\t// normalize skin weights to fix malformed assets (see #15319)\n\t\t\t\t\t\tmesh.normalizeSkinWeights();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP ) {\n\n\t\t\t\t\t\tmesh.geometry = toTrianglesDrawMode( mesh.geometry, TriangleStripDrawMode );\n\n\t\t\t\t\t} else if ( primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN ) {\n\n\t\t\t\t\t\tmesh.geometry = toTrianglesDrawMode( mesh.geometry, TriangleFanDrawMode );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( primitive.mode === WEBGL_CONSTANTS.LINES ) {\n\n\t\t\t\t\tmesh = new LineSegments( geometry, material );\n\n\t\t\t\t} else if ( primitive.mode === WEBGL_CONSTANTS.LINE_STRIP ) {\n\n\t\t\t\t\tmesh = new Line( geometry, material );\n\n\t\t\t\t} else if ( primitive.mode === WEBGL_CONSTANTS.LINE_LOOP ) {\n\n\t\t\t\t\tmesh = new LineLoop( geometry, material );\n\n\t\t\t\t} else if ( primitive.mode === WEBGL_CONSTANTS.POINTS ) {\n\n\t\t\t\t\tmesh = new Points( geometry, material );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthrow new Error( 'THREE.GLTFLoader: Primitive mode unsupported: ' + primitive.mode );\n\n\t\t\t\t}\n\n\t\t\t\tif ( Object.keys( mesh.geometry.morphAttributes ).length > 0 ) {\n\n\t\t\t\t\tupdateMorphTargets( mesh, meshDef );\n\n\t\t\t\t}\n\n\t\t\t\tmesh.name = parser.createUniqueName( meshDef.name || ( 'mesh_' + meshIndex ) );\n\n\t\t\t\tassignExtrasToUserData( mesh, meshDef );\n\n\t\t\t\tif ( primitive.extensions ) addUnknownExtensionsToUserData( extensions, mesh, primitive );\n\n\t\t\t\tparser.assignFinalMaterial( mesh );\n\n\t\t\t\tmeshes.push( mesh );\n\n\t\t\t}\n\n\t\t\tfor ( let i = 0, il = meshes.length; i < il; i ++ ) {\n\n\t\t\t\tparser.associations.set( meshes[ i ], {\n\t\t\t\t\tmeshes: meshIndex,\n\t\t\t\t\tprimitives: i\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tif ( meshes.length === 1 ) {\n\n\t\t\t\tif ( meshDef.extensions ) addUnknownExtensionsToUserData( extensions, meshes[ 0 ], meshDef );\n\n\t\t\t\treturn meshes[ 0 ];\n\n\t\t\t}\n\n\t\t\tconst group = new Group();\n\n\t\t\tif ( meshDef.extensions ) addUnknownExtensionsToUserData( extensions, group, meshDef );\n\n\t\t\tparser.associations.set( group, { meshes: meshIndex } );\n\n\t\t\tfor ( let i = 0, il = meshes.length; i < il; i ++ ) {\n\n\t\t\t\tgroup.add( meshes[ i ] );\n\n\t\t\t}\n\n\t\t\treturn group;\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras\n\t * @param {number} cameraIndex\n\t * @return {Promise<THREE.Camera>}\n\t */\n\tloadCamera( cameraIndex ) {\n\n\t\tlet camera;\n\t\tconst cameraDef = this.json.cameras[ cameraIndex ];\n\t\tconst params = cameraDef[ cameraDef.type ];\n\n\t\tif ( ! params ) {\n\n\t\t\tconsole.warn( 'THREE.GLTFLoader: Missing camera parameters.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( cameraDef.type === 'perspective' ) {\n\n\t\t\tcamera = new PerspectiveCamera( MathUtils.radToDeg( params.yfov ), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6 );\n\n\t\t} else if ( cameraDef.type === 'orthographic' ) {\n\n\t\t\tcamera = new OrthographicCamera( - params.xmag, params.xmag, params.ymag, - params.ymag, params.znear, params.zfar );\n\n\t\t}\n\n\t\tif ( cameraDef.name ) camera.name = this.createUniqueName( cameraDef.name );\n\n\t\tassignExtrasToUserData( camera, cameraDef );\n\n\t\treturn Promise.resolve( camera );\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins\n\t * @param {number} skinIndex\n\t * @return {Promise<Skeleton>}\n\t */\n\tloadSkin( skinIndex ) {\n\n\t\tconst skinDef = this.json.skins[ skinIndex ];\n\n\t\tconst pending = [];\n\n\t\tfor ( let i = 0, il = skinDef.joints.length; i < il; i ++ ) {\n\n\t\t\tpending.push( this._loadNodeShallow( skinDef.joints[ i ] ) );\n\n\t\t}\n\n\t\tif ( skinDef.inverseBindMatrices !== undefined ) {\n\n\t\t\tpending.push( this.getDependency( 'accessor', skinDef.inverseBindMatrices ) );\n\n\t\t} else {\n\n\t\t\tpending.push( null );\n\n\t\t}\n\n\t\treturn Promise.all( pending ).then( function ( results ) {\n\n\t\t\tconst inverseBindMatrices = results.pop();\n\t\t\tconst jointNodes = results;\n\n\t\t\t// Note that bones (joint nodes) may or may not be in the\n\t\t\t// scene graph at this time.\n\n\t\t\tconst bones = [];\n\t\t\tconst boneInverses = [];\n\n\t\t\tfor ( let i = 0, il = jointNodes.length; i < il; i ++ ) {\n\n\t\t\t\tconst jointNode = jointNodes[ i ];\n\n\t\t\t\tif ( jointNode ) {\n\n\t\t\t\t\tbones.push( jointNode );\n\n\t\t\t\t\tconst mat = new Matrix4();\n\n\t\t\t\t\tif ( inverseBindMatrices !== null ) {\n\n\t\t\t\t\t\tmat.fromArray( inverseBindMatrices.array, i * 16 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tboneInverses.push( mat );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.warn( 'THREE.GLTFLoader: Joint \"%s\" could not be found.', skinDef.joints[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn new Skeleton( bones, boneInverses );\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations\n\t * @param {number} animationIndex\n\t * @return {Promise<AnimationClip>}\n\t */\n\tloadAnimation( animationIndex ) {\n\n\t\tconst json = this.json;\n\t\tconst parser = this;\n\n\t\tconst animationDef = json.animations[ animationIndex ];\n\t\tconst animationName = animationDef.name ? animationDef.name : 'animation_' + animationIndex;\n\n\t\tconst pendingNodes = [];\n\t\tconst pendingInputAccessors = [];\n\t\tconst pendingOutputAccessors = [];\n\t\tconst pendingSamplers = [];\n\t\tconst pendingTargets = [];\n\n\t\tfor ( let i = 0, il = animationDef.channels.length; i < il; i ++ ) {\n\n\t\t\tconst channel = animationDef.channels[ i ];\n\t\t\tconst sampler = animationDef.samplers[ channel.sampler ];\n\t\t\tconst target = channel.target;\n\t\t\tconst name = target.node;\n\t\t\tconst input = animationDef.parameters !== undefined ? animationDef.parameters[ sampler.input ] : sampler.input;\n\t\t\tconst output = animationDef.parameters !== undefined ? animationDef.parameters[ sampler.output ] : sampler.output;\n\n\t\t\tif ( target.node === undefined ) continue;\n\n\t\t\tpendingNodes.push( this.getDependency( 'node', name ) );\n\t\t\tpendingInputAccessors.push( this.getDependency( 'accessor', input ) );\n\t\t\tpendingOutputAccessors.push( this.getDependency( 'accessor', output ) );\n\t\t\tpendingSamplers.push( sampler );\n\t\t\tpendingTargets.push( target );\n\n\t\t}\n\n\t\treturn Promise.all( [\n\n\t\t\tPromise.all( pendingNodes ),\n\t\t\tPromise.all( pendingInputAccessors ),\n\t\t\tPromise.all( pendingOutputAccessors ),\n\t\t\tPromise.all( pendingSamplers ),\n\t\t\tPromise.all( pendingTargets )\n\n\t\t] ).then( function ( dependencies ) {\n\n\t\t\tconst nodes = dependencies[ 0 ];\n\t\t\tconst inputAccessors = dependencies[ 1 ];\n\t\t\tconst outputAccessors = dependencies[ 2 ];\n\t\t\tconst samplers = dependencies[ 3 ];\n\t\t\tconst targets = dependencies[ 4 ];\n\n\t\t\tconst tracks = [];\n\n\t\t\tfor ( let i = 0, il = nodes.length; i < il; i ++ ) {\n\n\t\t\t\tconst node = nodes[ i ];\n\t\t\t\tconst inputAccessor = inputAccessors[ i ];\n\t\t\t\tconst outputAccessor = outputAccessors[ i ];\n\t\t\t\tconst sampler = samplers[ i ];\n\t\t\t\tconst target = targets[ i ];\n\n\t\t\t\tif ( node === undefined ) continue;\n\n\t\t\t\tif ( node.updateMatrix ) {\n\n\t\t\t\t\tnode.updateMatrix();\n\n\t\t\t\t}\n\n\t\t\t\tconst createdTracks = parser._createAnimationTracks( node, inputAccessor, outputAccessor, sampler, target );\n\n\t\t\t\tif ( createdTracks ) {\n\n\t\t\t\t\tfor ( let k = 0; k < createdTracks.length; k ++ ) {\n\n\t\t\t\t\t\ttracks.push( createdTracks[ k ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn new AnimationClip( animationName, undefined, tracks );\n\n\t\t} );\n\n\t}\n\n\tcreateNodeMesh( nodeIndex ) {\n\n\t\tconst json = this.json;\n\t\tconst parser = this;\n\t\tconst nodeDef = json.nodes[ nodeIndex ];\n\n\t\tif ( nodeDef.mesh === undefined ) return null;\n\n\t\treturn parser.getDependency( 'mesh', nodeDef.mesh ).then( function ( mesh ) {\n\n\t\t\tconst node = parser._getNodeRef( parser.meshCache, nodeDef.mesh, mesh );\n\n\t\t\t// if weights are provided on the node, override weights on the mesh.\n\t\t\tif ( nodeDef.weights !== undefined ) {\n\n\t\t\t\tnode.traverse( function ( o ) {\n\n\t\t\t\t\tif ( ! o.isMesh ) return;\n\n\t\t\t\t\tfor ( let i = 0, il = nodeDef.weights.length; i < il; i ++ ) {\n\n\t\t\t\t\t\to.morphTargetInfluences[ i ] = nodeDef.weights[ i ];\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\treturn node;\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy\n\t * @param {number} nodeIndex\n\t * @return {Promise<Object3D>}\n\t */\n\tloadNode( nodeIndex ) {\n\n\t\tconst json = this.json;\n\t\tconst parser = this;\n\n\t\tconst nodeDef = json.nodes[ nodeIndex ];\n\n\t\tconst nodePending = parser._loadNodeShallow( nodeIndex );\n\n\t\tconst childPending = [];\n\t\tconst childrenDef = nodeDef.children || [];\n\n\t\tfor ( let i = 0, il = childrenDef.length; i < il; i ++ ) {\n\n\t\t\tchildPending.push( parser.getDependency( 'node', childrenDef[ i ] ) );\n\n\t\t}\n\n\t\tconst skeletonPending = nodeDef.skin === undefined\n\t\t\t? Promise.resolve( null )\n\t\t\t: parser.getDependency( 'skin', nodeDef.skin );\n\n\t\treturn Promise.all( [\n\t\t\tnodePending,\n\t\t\tPromise.all( childPending ),\n\t\t\tskeletonPending\n\t\t] ).then( function ( results ) {\n\n\t\t\tconst node = results[ 0 ];\n\t\t\tconst children = results[ 1 ];\n\t\t\tconst skeleton = results[ 2 ];\n\n\t\t\tif ( skeleton !== null ) {\n\n\t\t\t\t// This full traverse should be fine because\n\t\t\t\t// child glTF nodes have not been added to this node yet.\n\t\t\t\tnode.traverse( function ( mesh ) {\n\n\t\t\t\t\tif ( ! mesh.isSkinnedMesh ) return;\n\n\t\t\t\t\tmesh.bind( skeleton, _identityMatrix );\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tfor ( let i = 0, il = children.length; i < il; i ++ ) {\n\n\t\t\t\tnode.add( children[ i ] );\n\n\t\t\t}\n\n\t\t\treturn node;\n\n\t\t} );\n\n\t}\n\n\t// ._loadNodeShallow() parses a single node.\n\t// skin and child nodes are created and added in .loadNode() (no '_' prefix).\n\t_loadNodeShallow( nodeIndex ) {\n\n\t\tconst json = this.json;\n\t\tconst extensions = this.extensions;\n\t\tconst parser = this;\n\n\t\t// This method is called from .loadNode() and .loadSkin().\n\t\t// Cache a node to avoid duplication.\n\n\t\tif ( this.nodeCache[ nodeIndex ] !== undefined ) {\n\n\t\t\treturn this.nodeCache[ nodeIndex ];\n\n\t\t}\n\n\t\tconst nodeDef = json.nodes[ nodeIndex ];\n\n\t\t// reserve node's name before its dependencies, so the root has the intended name.\n\t\tconst nodeName = nodeDef.name ? parser.createUniqueName( nodeDef.name ) : '';\n\n\t\tconst pending = [];\n\n\t\tconst meshPromise = parser._invokeOne( function ( ext ) {\n\n\t\t\treturn ext.createNodeMesh && ext.createNodeMesh( nodeIndex );\n\n\t\t} );\n\n\t\tif ( meshPromise ) {\n\n\t\t\tpending.push( meshPromise );\n\n\t\t}\n\n\t\tif ( nodeDef.camera !== undefined ) {\n\n\t\t\tpending.push( parser.getDependency( 'camera', nodeDef.camera ).then( function ( camera ) {\n\n\t\t\t\treturn parser._getNodeRef( parser.cameraCache, nodeDef.camera, camera );\n\n\t\t\t} ) );\n\n\t\t}\n\n\t\tparser._invokeAll( function ( ext ) {\n\n\t\t\treturn ext.createNodeAttachment && ext.createNodeAttachment( nodeIndex );\n\n\t\t} ).forEach( function ( promise ) {\n\n\t\t\tpending.push( promise );\n\n\t\t} );\n\n\t\tthis.nodeCache[ nodeIndex ] = Promise.all( pending ).then( function ( objects ) {\n\n\t\t\tlet node;\n\n\t\t\t// .isBone isn't in glTF spec. See ._markDefs\n\t\t\tif ( nodeDef.isBone === true ) {\n\n\t\t\t\tnode = new Bone();\n\n\t\t\t} else if ( objects.length > 1 ) {\n\n\t\t\t\tnode = new Group();\n\n\t\t\t} else if ( objects.length === 1 ) {\n\n\t\t\t\tnode = objects[ 0 ];\n\n\t\t\t} else {\n\n\t\t\t\tnode = new Object3D();\n\n\t\t\t}\n\n\t\t\tif ( node !== objects[ 0 ] ) {\n\n\t\t\t\tfor ( let i = 0, il = objects.length; i < il; i ++ ) {\n\n\t\t\t\t\tnode.add( objects[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( nodeDef.name ) {\n\n\t\t\t\tnode.userData.name = nodeDef.name;\n\t\t\t\tnode.name = nodeName;\n\n\t\t\t}\n\n\t\t\tassignExtrasToUserData( node, nodeDef );\n\n\t\t\tif ( nodeDef.extensions ) addUnknownExtensionsToUserData( extensions, node, nodeDef );\n\n\t\t\tif ( nodeDef.matrix !== undefined ) {\n\n\t\t\t\tconst matrix = new Matrix4();\n\t\t\t\tmatrix.fromArray( nodeDef.matrix );\n\t\t\t\tnode.applyMatrix4( matrix );\n\n\t\t\t} else {\n\n\t\t\t\tif ( nodeDef.translation !== undefined ) {\n\n\t\t\t\t\tnode.position.fromArray( nodeDef.translation );\n\n\t\t\t\t}\n\n\t\t\t\tif ( nodeDef.rotation !== undefined ) {\n\n\t\t\t\t\tnode.quaternion.fromArray( nodeDef.rotation );\n\n\t\t\t\t}\n\n\t\t\t\tif ( nodeDef.scale !== undefined ) {\n\n\t\t\t\t\tnode.scale.fromArray( nodeDef.scale );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( ! parser.associations.has( node ) ) {\n\n\t\t\t\tparser.associations.set( node, {} );\n\n\t\t\t}\n\n\t\t\tparser.associations.get( node ).nodes = nodeIndex;\n\n\t\t\treturn node;\n\n\t\t} );\n\n\t\treturn this.nodeCache[ nodeIndex ];\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes\n\t * @param {number} sceneIndex\n\t * @return {Promise<Group>}\n\t */\n\tloadScene( sceneIndex ) {\n\n\t\tconst extensions = this.extensions;\n\t\tconst sceneDef = this.json.scenes[ sceneIndex ];\n\t\tconst parser = this;\n\n\t\t// Loader returns Group, not Scene.\n\t\t// See: https://github.com/mrdoob/three.js/issues/18342#issuecomment-578981172\n\t\tconst scene = new Group();\n\t\tif ( sceneDef.name ) scene.name = parser.createUniqueName( sceneDef.name );\n\n\t\tassignExtrasToUserData( scene, sceneDef );\n\n\t\tif ( sceneDef.extensions ) addUnknownExtensionsToUserData( extensions, scene, sceneDef );\n\n\t\tconst nodeIds = sceneDef.nodes || [];\n\n\t\tconst pending = [];\n\n\t\tfor ( let i = 0, il = nodeIds.length; i < il; i ++ ) {\n\n\t\t\tpending.push( parser.getDependency( 'node', nodeIds[ i ] ) );\n\n\t\t}\n\n\t\treturn Promise.all( pending ).then( function ( nodes ) {\n\n\t\t\tfor ( let i = 0, il = nodes.length; i < il; i ++ ) {\n\n\t\t\t\tscene.add( nodes[ i ] );\n\n\t\t\t}\n\n\t\t\t// Removes dangling associations, associations that reference a node that\n\t\t\t// didn't make it into the scene.\n\t\t\tconst reduceAssociations = ( node ) => {\n\n\t\t\t\tconst reducedAssociations = new Map();\n\n\t\t\t\tfor ( const [ key, value ] of parser.associations ) {\n\n\t\t\t\t\tif ( key instanceof Material || key instanceof Texture ) {\n\n\t\t\t\t\t\treducedAssociations.set( key, value );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tnode.traverse( ( node ) => {\n\n\t\t\t\t\tconst mappings = parser.associations.get( node );\n\n\t\t\t\t\tif ( mappings != null ) {\n\n\t\t\t\t\t\treducedAssociations.set( node, mappings );\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\treturn reducedAssociations;\n\n\t\t\t};\n\n\t\t\tparser.associations = reduceAssociations( scene );\n\n\t\t\treturn scene;\n\n\t\t} );\n\n\t}\n\n\t_createAnimationTracks( node, inputAccessor, outputAccessor, sampler, target ) {\n\n\t\tconst tracks = [];\n\n\t\tconst targetName = node.name ? node.name : node.uuid;\n\t\tconst targetNames = [];\n\n\t\tif ( PATH_PROPERTIES[ target.path ] === PATH_PROPERTIES.weights ) {\n\n\t\t\tnode.traverse( function ( object ) {\n\n\t\t\t\tif ( object.morphTargetInfluences ) {\n\n\t\t\t\t\ttargetNames.push( object.name ? object.name : object.uuid );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t} else {\n\n\t\t\ttargetNames.push( targetName );\n\n\t\t}\n\n\t\tlet TypedKeyframeTrack;\n\n\t\tswitch ( PATH_PROPERTIES[ target.path ] ) {\n\n\t\t\tcase PATH_PROPERTIES.weights:\n\n\t\t\t\tTypedKeyframeTrack = NumberKeyframeTrack;\n\t\t\t\tbreak;\n\n\t\t\tcase PATH_PROPERTIES.rotation:\n\n\t\t\t\tTypedKeyframeTrack = QuaternionKeyframeTrack;\n\t\t\t\tbreak;\n\n\t\t\tcase PATH_PROPERTIES.position:\n\t\t\tcase PATH_PROPERTIES.scale:\n\n\t\t\t\tTypedKeyframeTrack = VectorKeyframeTrack;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\n\t\t\t\tswitch ( outputAccessor.itemSize ) {\n\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tTypedKeyframeTrack = NumberKeyframeTrack;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\tcase 3:\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tTypedKeyframeTrack = VectorKeyframeTrack;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\tconst interpolation = sampler.interpolation !== undefined ? INTERPOLATION[ sampler.interpolation ] : InterpolateLinear;\n\n\n\t\tconst outputArray = this._getArrayFromAccessor( outputAccessor );\n\n\t\tfor ( let j = 0, jl = targetNames.length; j < jl; j ++ ) {\n\n\t\t\tconst track = new TypedKeyframeTrack(\n\t\t\t\ttargetNames[ j ] + '.' + PATH_PROPERTIES[ target.path ],\n\t\t\t\tinputAccessor.array,\n\t\t\t\toutputArray,\n\t\t\t\tinterpolation\n\t\t\t);\n\n\t\t\t// Override interpolation with custom factory method.\n\t\t\tif ( sampler.interpolation === 'CUBICSPLINE' ) {\n\n\t\t\t\tthis._createCubicSplineTrackInterpolant( track );\n\n\t\t\t}\n\n\t\t\ttracks.push( track );\n\n\t\t}\n\n\t\treturn tracks;\n\n\t}\n\n\t_getArrayFromAccessor( accessor ) {\n\n\t\tlet outputArray = accessor.array;\n\n\t\tif ( accessor.normalized ) {\n\n\t\t\tconst scale = getNormalizedComponentScale( outputArray.constructor );\n\t\t\tconst scaled = new Float32Array( outputArray.length );\n\n\t\t\tfor ( let j = 0, jl = outputArray.length; j < jl; j ++ ) {\n\n\t\t\t\tscaled[ j ] = outputArray[ j ] * scale;\n\n\t\t\t}\n\n\t\t\toutputArray = scaled;\n\n\t\t}\n\n\t\treturn outputArray;\n\n\t}\n\n\t_createCubicSplineTrackInterpolant( track ) {\n\n\t\ttrack.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline( result ) {\n\n\t\t\t// A CUBICSPLINE keyframe in glTF has three output values for each input value,\n\t\t\t// representing inTangent, splineVertex, and outTangent. As a result, track.getValueSize()\n\t\t\t// must be divided by three to get the interpolant's sampleSize argument.\n\n\t\t\tconst interpolantType = ( this instanceof QuaternionKeyframeTrack ) ? GLTFCubicSplineQuaternionInterpolant : GLTFCubicSplineInterpolant;\n\n\t\t\treturn new interpolantType( this.times, this.values, this.getValueSize() / 3, result );\n\n\t\t};\n\n\t\t// Mark as CUBICSPLINE. `track.getInterpolation()` doesn't support custom interpolants.\n\t\ttrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;\n\n\t}\n\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @param {GLTF.Primitive} primitiveDef\n * @param {GLTFParser} parser\n */\nfunction computeBounds( geometry, primitiveDef, parser ) {\n\n\tconst attributes = primitiveDef.attributes;\n\n\tconst box = new Box3();\n\n\tif ( attributes.POSITION !== undefined ) {\n\n\t\tconst accessor = parser.json.accessors[ attributes.POSITION ];\n\n\t\tconst min = accessor.min;\n\t\tconst max = accessor.max;\n\n\t\t// glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.\n\n\t\tif ( min !== undefined && max !== undefined ) {\n\n\t\t\tbox.set(\n\t\t\t\tnew Vector3( min[ 0 ], min[ 1 ], min[ 2 ] ),\n\t\t\t\tnew Vector3( max[ 0 ], max[ 1 ], max[ 2 ] )\n\t\t\t);\n\n\t\t\tif ( accessor.normalized ) {\n\n\t\t\t\tconst boxScale = getNormalizedComponentScale( WEBGL_COMPONENT_TYPES[ accessor.componentType ] );\n\t\t\t\tbox.min.multiplyScalar( boxScale );\n\t\t\t\tbox.max.multiplyScalar( boxScale );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'THREE.GLTFLoader: Missing min/max properties for accessor POSITION.' );\n\n\t\t\treturn;\n\n\t\t}\n\n\t} else {\n\n\t\treturn;\n\n\t}\n\n\tconst targets = primitiveDef.targets;\n\n\tif ( targets !== undefined ) {\n\n\t\tconst maxDisplacement = new Vector3();\n\t\tconst vector = new Vector3();\n\n\t\tfor ( let i = 0, il = targets.length; i < il; i ++ ) {\n\n\t\t\tconst target = targets[ i ];\n\n\t\t\tif ( target.POSITION !== undefined ) {\n\n\t\t\t\tconst accessor = parser.json.accessors[ target.POSITION ];\n\t\t\t\tconst min = accessor.min;\n\t\t\t\tconst max = accessor.max;\n\n\t\t\t\t// glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.\n\n\t\t\t\tif ( min !== undefined && max !== undefined ) {\n\n\t\t\t\t\t// we need to get max of absolute components because target weight is [-1,1]\n\t\t\t\t\tvector.setX( Math.max( Math.abs( min[ 0 ] ), Math.abs( max[ 0 ] ) ) );\n\t\t\t\t\tvector.setY( Math.max( Math.abs( min[ 1 ] ), Math.abs( max[ 1 ] ) ) );\n\t\t\t\t\tvector.setZ( Math.max( Math.abs( min[ 2 ] ), Math.abs( max[ 2 ] ) ) );\n\n\n\t\t\t\t\tif ( accessor.normalized ) {\n\n\t\t\t\t\t\tconst boxScale = getNormalizedComponentScale( WEBGL_COMPONENT_TYPES[ accessor.componentType ] );\n\t\t\t\t\t\tvector.multiplyScalar( boxScale );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// Note: this assumes that the sum of all weights is at most 1. This isn't quite correct - it's more conservative\n\t\t\t\t\t// to assume that each target can have a max weight of 1. However, for some use cases - notably, when morph targets\n\t\t\t\t\t// are used to implement key-frame animations and as such only two are active at a time - this results in very large\n\t\t\t\t\t// boxes. So for now we make a box that's sometimes a touch too small but is hopefully mostly of reasonable size.\n\t\t\t\t\tmaxDisplacement.max( vector );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.warn( 'THREE.GLTFLoader: Missing min/max properties for accessor POSITION.' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// As per comment above this box isn't conservative, but has a reasonable size for a very large number of morph targets.\n\t\tbox.expandByVector( maxDisplacement );\n\n\t}\n\n\tgeometry.boundingBox = box;\n\n\tconst sphere = new Sphere();\n\n\tbox.getCenter( sphere.center );\n\tsphere.radius = box.min.distanceTo( box.max ) / 2;\n\n\tgeometry.boundingSphere = sphere;\n\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @param {GLTF.Primitive} primitiveDef\n * @param {GLTFParser} parser\n * @return {Promise<BufferGeometry>}\n */\nfunction addPrimitiveAttributes( geometry, primitiveDef, parser ) {\n\n\tconst attributes = primitiveDef.attributes;\n\n\tconst pending = [];\n\n\tfunction assignAttributeAccessor( accessorIndex, attributeName ) {\n\n\t\treturn parser.getDependency( 'accessor', accessorIndex )\n\t\t\t.then( function ( accessor ) {\n\n\t\t\t\tgeometry.setAttribute( attributeName, accessor );\n\n\t\t\t} );\n\n\t}\n\n\tfor ( const gltfAttributeName in attributes ) {\n\n\t\tconst threeAttributeName = ATTRIBUTES[ gltfAttributeName ] || gltfAttributeName.toLowerCase();\n\n\t\t// Skip attributes already provided by e.g. Draco extension.\n\t\tif ( threeAttributeName in geometry.attributes ) continue;\n\n\t\tpending.push( assignAttributeAccessor( attributes[ gltfAttributeName ], threeAttributeName ) );\n\n\t}\n\n\tif ( primitiveDef.indices !== undefined && ! geometry.index ) {\n\n\t\tconst accessor = parser.getDependency( 'accessor', primitiveDef.indices ).then( function ( accessor ) {\n\n\t\t\tgeometry.setIndex( accessor );\n\n\t\t} );\n\n\t\tpending.push( accessor );\n\n\t}\n\n\tif ( ColorManagement.workingColorSpace !== LinearSRGBColorSpace && 'COLOR_0' in attributes ) {\n\n\t\tconsole.warn( `THREE.GLTFLoader: Converting vertex colors from \"srgb-linear\" to \"${ColorManagement.workingColorSpace}\" not supported.` );\n\n\t}\n\n\tassignExtrasToUserData( geometry, primitiveDef );\n\n\tcomputeBounds( geometry, primitiveDef, parser );\n\n\treturn Promise.all( pending ).then( function () {\n\n\t\treturn primitiveDef.targets !== undefined\n\t\t\t? addMorphTargets( geometry, primitiveDef.targets, parser )\n\t\t\t: geometry;\n\n\t} );\n\n}\n\nexport { GLTFLoader };\n","<template>\n  <div\n    class=\"wrapper pa-4\"\n  >\n    <h1>载入3D模型（Loading 3D models）</h1>\n    <canvas\n      id=\"c\"\n      class=\"full-bleed\"\n    />\n    <highlightjs\n      class=\"mt-4\"\n      :code=\"`${code}`\"\n      :language=\"'js'\"\n    />\n  </div>\n</template>\n\n<script type=\"module\">\nimport * as THREE from 'three';\nimport { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';\n\nconst loader = new GLTFLoader();\n\nexport default {\n  data() {\n    return {\n      fov: 75, // 相机视野范围\n      aspect: 2, // 画布的宽高比 在默认情况下 canvas画布是300x150像素，所以宽高比为300/150或者说2\n      near: 0.1, // 相机近平面\n      far: 5, // 相机远平面\n\n      boxWidth: 1,\n      boxHeight: 1,\n      boxDepth: 1,\n\n      code: `// 加载 glb 文件\n// 这个可以的 但是我在vue目录 和 /public里都放了一个\nloader.load( 'stone.glb', function ( gltf ) {\n  scene.add( gltf.scene );\n}, undefined, function ( error ) {\n  console.error( error );\n} );\n\n// 加载 gltf 文件 \n// 放在 /public 里\nloader.load( '/free_ac_unit/scene.gltf', function ( gltf ) {\n  scene.add( gltf.scene );\n}, undefined, function ( error ) {\n  console.error( error );\n} );\n\n// 加载 gltf 文件\n// 放在GitHub上文件路径有问题 铐\nloader.load( '/stylized_stones_props/scene.gltf', function ( gltf ) {\n  scene.add( gltf.scene );\n}, undefined, function ( error ) {\n  console.error( error );\n} );`,\n    };\n  },\n  mounted() {\n    this.main();\n  },\n  methods: {\n    main() {\n      // canvas\n      const canvas = document.querySelector('#c');\n      // 渲染器 antialias代表是否开启抗锯齿\n      const renderer = new THREE.WebGLRenderer({antialias: true, canvas});\n      renderer.setSize( window.innerWidth, window.innerHeight - 300, false );\n      const camera = new THREE.PerspectiveCamera(65,  window.innerWidth / window.innerHeight, 1, 500 );\n\n      // 摄像机位置 xyz\n      camera.position.set( 0, 0, 5);\n      camera.lookAt( 0, 0, -0.2 );\n\n      // 创建场景\n      const scene = new THREE.Scene();\n\n      // 几何体 宽 高 深\n      const geometry = new THREE.BoxGeometry(1, 1, 1);\n\n      // 材质\n      const material = new THREE.MeshPhongMaterial({\n        color: '#FFDD11',\n      });\n\n      // 再创建一个网格(Mesh)对象，它包含了 geometry(几何体 物体的形状) material(材质 如何绘制物体，光滑还是平整，什么颜色，什么贴图..)\n      const cube = new THREE.Mesh(geometry, material);\n      // 位置\n      cube.position.set( 2, 0, 0 );\n      // 最后我们将网格添加到场景中。\n      scene.add(cube);\n\n      // // 加载 glb 文件\n      loader.load( 'stone.glb', function ( gltf ) {\n        scene.add( gltf.scene );\n      }, undefined, function ( error ) {\n        console.error( error );\n      } );\n\n      // // 加载 gltf 文件 \n      // loader.load( '/free_ac_unit/scene.gltf', function ( gltf ) {\n      //   scene.add( gltf.scene );\n      // }, undefined, function ( error ) {\n      //   console.error( error );\n      // } );\n\n      // 加载 gltf 文件\n      // 放在GitHub上文件路径有问题\n      // loader.load( '/stylized_stones_props/scene.gltf', function ( gltf ) {\n      //   scene.add( gltf.scene );\n      // }, undefined, function ( error ) {\n      //   console.error( error );\n      // } );\n\n      // 之后将场景和摄像机传递给渲染器来渲染出整个场景。\n      renderer.render(scene, camera);\n\n      // 灯光\n      const color = 0xFFFFFF;\n      const intensity = 3;\n      const light = new THREE.DirectionalLight(color, intensity);\n      light.position.set(-1, 2, 4); // 位置\n      scene.add(light);\n\n      // 判断画布是否需要调整大小\n      function resizeRendererToDisplaySize(renderer) {\n        const canvas = renderer.domElement;\n        const width = canvas.clientWidth;\n        const height = canvas.clientHeight;\n        const needResize = canvas.width !== width || canvas.height !== height;\n        if (needResize) {\n          renderer.setSize(width, height, false);\n        }\n        return needResize;\n      }\n\n      // 立方体旋转\n      function render(time) {\n        time *= 0.001;  // 将时间单位变为秒\n\n        // 注意如果我们的canvas大小被调整了那函数会返回true。我们可以利用 这个来检查是否有其他的东西应该更新。我们修改渲染循环 来使用我们的新函数\n        if (resizeRendererToDisplaySize(renderer)) {\n          const canvas = renderer.domElement;\n          camera.aspect = canvas.clientWidth / canvas.clientHeight;\n          camera.updateProjectionMatrix();\n        }\n      \n        cube.rotation.x = time;\n        cube.rotation.y = time;\n      \n        renderer.render(scene, camera);\n      \n        requestAnimationFrame(render);\n      }\n      requestAnimationFrame(render);\n    },\n  }\n}\n</script>\n\n<style scoped>\n.wrapper {\n  display: grid;\n  grid-template-columns:\n    1fr\n    min(65ch, 100%)\n    1fr;\n}\n\n.wrapper > * {\n  grid-column: 2;\n}\n\n.full-bleed {\n  width: 100%;\n  grid-column: 1 / -1;\n}\n\n</style>","import mod from \"-!../../../../../node_modules/cache-loader/dist/cjs.js??ref--13-0!../../../../../node_modules/thread-loader/dist/cjs.js!../../../../../node_modules/babel-loader/lib/index.js!../../../../../node_modules/cache-loader/dist/cjs.js??ref--1-0!../../../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./threejs6.vue?vue&type=script&lang=js\"; export default mod; export * from \"-!../../../../../node_modules/cache-loader/dist/cjs.js??ref--13-0!../../../../../node_modules/thread-loader/dist/cjs.js!../../../../../node_modules/babel-loader/lib/index.js!../../../../../node_modules/cache-loader/dist/cjs.js??ref--1-0!../../../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./threejs6.vue?vue&type=script&lang=js\"","import { render, staticRenderFns } from \"./threejs6.vue?vue&type=template&id=34c7ad35&scoped=true\"\nimport script from \"./threejs6.vue?vue&type=script&lang=js\"\nexport * from \"./threejs6.vue?vue&type=script&lang=js\"\nimport style0 from \"./threejs6.vue?vue&type=style&index=0&id=34c7ad35&prod&scoped=true&lang=css\"\n\n\n/* normalize component */\nimport normalizer from \"!../../../../../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  \"34c7ad35\",\n  null\n  \n)\n\nexport default component.exports","'use strict';\nvar $TypeError = TypeError;\n\nmodule.exports = function (passed, required) {\n  if (passed < required) throw new $TypeError('Not enough arguments');\n  return passed;\n};\n","'use strict';\nvar defineBuiltIn = require('../internals/define-built-in');\nvar uncurryThis = require('../internals/function-uncurry-this');\nvar toString = require('../internals/to-string');\nvar validateArgumentsLength = require('../internals/validate-arguments-length');\n\nvar $URLSearchParams = URLSearchParams;\nvar URLSearchParamsPrototype = $URLSearchParams.prototype;\nvar getAll = uncurryThis(URLSearchParamsPrototype.getAll);\nvar $has = uncurryThis(URLSearchParamsPrototype.has);\nvar params = new $URLSearchParams('a=1');\n\n// `undefined` case is a Chromium 117 bug\n// https://bugs.chromium.org/p/v8/issues/detail?id=14222\nif (params.has('a', 2) || !params.has('a', undefined)) {\n  defineBuiltIn(URLSearchParamsPrototype, 'has', function has(name /* , value */) {\n    var length = arguments.length;\n    var $value = length < 2 ? undefined : arguments[1];\n    if (length && $value === undefined) return $has(this, name);\n    var values = getAll(this, name); // also validates `this`\n    validateArgumentsLength(length, 1);\n    var value = toString($value);\n    var index = 0;\n    while (index < values.length) {\n      if (values[index++] === value) return true;\n    } return false;\n  }, { enumerable: true, unsafe: true });\n}\n","export * from \"-!../../../../../node_modules/mini-css-extract-plugin/dist/loader.js??ref--7-oneOf-1-0!../../../../../node_modules/css-loader/dist/cjs.js??ref--7-oneOf-1-1!../../../../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../../../../node_modules/postcss-loader/src/index.js??ref--7-oneOf-1-2!../../../../../node_modules/cache-loader/dist/cjs.js??ref--1-0!../../../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./threejs4.vue?vue&type=style&index=0&id=7fbec5a2&prod&scoped=true&lang=css\""],"sourceRoot":""}